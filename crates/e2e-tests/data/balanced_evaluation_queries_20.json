{
  "metadata": {
    "created": "2025-10-23",
    "purpose": "Reduced balanced evaluation set for IR metrics (NDCG, Precision, Recall, MRR)",
    "total_queries": 20,
    "semantic_queries": 10,
    "keyword_queries": 10
  },
  "queries": [
    {
      "id": "semantic-1",
      "query_type": "semantic",
      "query": "I need to create a CLI application that accepts configuration from both command line arguments and environment variables, with command line taking precedence. How does clap handle this pattern?",
      "bge_instruction": "Represent this detailed technical question about software configuration patterns and precedence rules for retrieving relevant code implementations and architectural designs",
      "expected_entity_types": [
        "Function",
        "Method",
        "Struct",
        "Impl"
      ],
      "expected_concepts": [
        "environment variables",
        "argument precedence",
        "configuration merging"
      ]
    },
    {
      "id": "semantic-2",
      "query_type": "semantic",
      "query": "Show me how clap implements the builder pattern for constructing command line interfaces, including method chaining and immutability",
      "bge_instruction": "Represent this technical question about design patterns and API architecture for retrieving code examples demonstrating builder pattern implementation with method chaining",
      "expected_entity_types": [
        "Impl",
        "Method",
        "Struct"
      ],
      "expected_concepts": [
        "builder pattern",
        "method chaining",
        "fluent API"
      ]
    },
    {
      "id": "semantic-3",
      "query_type": "semantic",
      "query": "I want to understand how clap validates that mutually exclusive arguments aren't provided together at runtime",
      "bge_instruction": "Represent this technical question about validation logic and constraint checking for retrieving runtime validation implementations and conflict detection algorithms",
      "expected_entity_types": [
        "Function",
        "Method"
      ],
      "expected_concepts": [
        "validation",
        "mutual exclusion",
        "conflict detection"
      ]
    },
    {
      "id": "semantic-4",
      "query_type": "semantic",
      "query": "Find the architecture for parsing raw command line strings into structured data with type safety",
      "bge_instruction": "Represent this technical question about parsing architecture and type systems for retrieving parser implementations and type conversion logic",
      "expected_entity_types": [
        "Function",
        "Struct",
        "Trait",
        "Impl"
      ],
      "expected_concepts": [
        "parsing",
        "type safety",
        "string processing"
      ]
    },
    {
      "id": "semantic-5",
      "query_type": "semantic",
      "query": "How does clap generate helpful error messages when users provide invalid input, including suggestions for corrections?",
      "bge_instruction": "Represent this technical question about error handling and user experience for retrieving error formatting code and suggestion generation algorithms",
      "expected_entity_types": [
        "Function",
        "Method",
        "Struct"
      ],
      "expected_concepts": [
        "error messages",
        "suggestions",
        "user feedback"
      ]
    },
    {
      "id": "semantic-6",
      "query_type": "semantic",
      "query": "Show me the pattern for creating subcommands with their own argument sets that inherit global options",
      "bge_instruction": "Represent this technical question about hierarchical command structures and option inheritance for retrieving subcommand implementation patterns and configuration propagation logic",
      "expected_entity_types": [
        "Method",
        "Function",
        "Impl"
      ],
      "expected_concepts": [
        "subcommands",
        "inheritance",
        "global options"
      ]
    },
    {
      "id": "semantic-7",
      "query_type": "semantic",
      "query": "I need to understand how clap handles the difference between required arguments, optional arguments, and flags with their different behaviors",
      "bge_instruction": "Represent this technical question about argument types and behavioral distinctions for retrieving code that differentiates between argument kinds and their validation rules",
      "expected_entity_types": [
        "Method",
        "Function",
        "Enum"
      ],
      "expected_concepts": [
        "required",
        "optional",
        "flags",
        "argument types"
      ]
    },
    {
      "id": "semantic-8",
      "query_type": "semantic",
      "query": "Find the implementation of auto-generating shell completion scripts from the command definition",
      "bge_instruction": "Represent this technical question about code generation and shell integration for retrieving completion script generation logic and command metadata extraction",
      "expected_entity_types": [
        "Function",
        "Method",
        "Module"
      ],
      "expected_concepts": [
        "completion",
        "code generation",
        "shell integration"
      ]
    },
    {
      "id": "semantic-9",
      "query_type": "semantic",
      "query": "How does clap handle the precedence and conflict resolution when multiple arguments or sources affect the same configuration value?",
      "bge_instruction": "Represent this technical question about conflict resolution algorithms and precedence rules for retrieving conflict detection logic and value merging strategies",
      "expected_entity_types": [
        "Function",
        "Method"
      ],
      "expected_concepts": [
        "precedence",
        "conflict resolution",
        "multiple sources"
      ]
    },
    {
      "id": "semantic-10",
      "query_type": "semantic",
      "query": "Show me how clap supports custom value parsers with validation and type conversion, including error handling",
      "bge_instruction": "Represent this technical question about extensibility patterns and custom validation for retrieving trait definitions for value parsing and examples of custom parser implementations",
      "expected_entity_types": [
        "Trait",
        "Impl",
        "Function"
      ],
      "expected_concepts": [
        "custom parsers",
        "validation",
        "type conversion"
      ]
    },
    {
      "id": "keyword-1",
      "query_type": "keyword",
      "query": "Arg",
      "bge_instruction": "Represent this exact struct name for precise retrieval",
      "expected_entity_types": [
        "Struct"
      ],
      "expected_concepts": [
        "Arg"
      ]
    },
    {
      "id": "keyword-2",
      "query_type": "keyword",
      "query": "Command",
      "bge_instruction": "Represent this exact struct name for precise retrieval",
      "expected_entity_types": [
        "Struct"
      ],
      "expected_concepts": [
        "Command"
      ]
    },
    {
      "id": "keyword-3",
      "query_type": "keyword",
      "query": "ArgMatches",
      "bge_instruction": "Represent this exact struct name for precise retrieval",
      "expected_entity_types": [
        "Struct"
      ],
      "expected_concepts": [
        "ArgMatches"
      ]
    },
    {
      "id": "keyword-4",
      "query_type": "keyword",
      "query": "required",
      "bge_instruction": "Represent this method name for exact retrieval",
      "expected_entity_types": [
        "Method"
      ],
      "expected_concepts": [
        "required"
      ]
    },
    {
      "id": "keyword-5",
      "query_type": "keyword",
      "query": "value_parser",
      "bge_instruction": "Represent this method name for exact retrieval",
      "expected_entity_types": [
        "Method"
      ],
      "expected_concepts": [
        "value_parser"
      ]
    },
    {
      "id": "keyword-6",
      "query_type": "keyword",
      "query": "subcommand",
      "bge_instruction": "Represent this method name for exact retrieval",
      "expected_entity_types": [
        "Method"
      ],
      "expected_concepts": [
        "subcommand"
      ]
    },
    {
      "id": "keyword-7",
      "query_type": "keyword",
      "query": "default_value",
      "bge_instruction": "Represent this method name for exact retrieval",
      "expected_entity_types": [
        "Method"
      ],
      "expected_concepts": [
        "default_value"
      ]
    },
    {
      "id": "keyword-8",
      "query_type": "keyword",
      "query": "conflicts_with",
      "bge_instruction": "Represent this method name for exact retrieval",
      "expected_entity_types": [
        "Method"
      ],
      "expected_concepts": [
        "conflicts_with"
      ]
    },
    {
      "id": "keyword-9",
      "query_type": "keyword",
      "query": "TypedValueParser",
      "bge_instruction": "Represent this trait name for exact retrieval",
      "expected_entity_types": [
        "Trait"
      ],
      "expected_concepts": [
        "TypedValueParser"
      ]
    },
    {
      "id": "keyword-10",
      "query_type": "keyword",
      "query": "ValueEnum",
      "bge_instruction": "Represent this trait name for exact retrieval",
      "expected_entity_types": [
        "Trait"
      ],
      "expected_concepts": [
        "ValueEnum"
      ]
    }
  ]
}