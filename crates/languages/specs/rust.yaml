# Rust Entity Extraction Specification
# ====================================
#
# This specification defines the rules for extracting entities, relationships,
# and metadata from Rust source code. Rules are identified by unique IDs and
# can be referenced by test fixtures.
#
# Rule ID Format:
#   E-xxx  = Entity extraction rules
#   V-xxx  = Visibility rules
#   Q-xxx  = Qualified name rules
#   R-xxx  = Relationship rules
#   M-xxx  = Metadata rules
#
# Reference: https://doc.rust-lang.org/reference/
#
# Last validated against Rust Reference: 2025-12-31

version: "1.0"
language: rust

# =============================================================================
# ENTITY TYPES
# =============================================================================
# Defines which Rust constructs produce which entity types.

entity_rules:

  # ---------------------------------------------------------------------------
  # Modules
  # ---------------------------------------------------------------------------
  - id: E-MOD-CRATE
    description: "The crate root produces a Module entity"
    construct: "crate root (lib.rs or main.rs)"
    produces: Module
    tested_by: [basic_mod, visibility, free_functions]

  - id: E-MOD-DECL
    description: "A mod declaration produces a Module entity"
    construct: "mod foo;"
    produces: Module
    tested_by: [basic_mod, deep_module_nesting]

  - id: E-MOD-INLINE
    description: "An inline mod block produces a Module entity"
    construct: "mod foo { ... }"
    produces: Module
    tested_by: [mixed_module_structure]

  # ---------------------------------------------------------------------------
  # Functions
  # ---------------------------------------------------------------------------
  - id: E-FN-FREE
    description: "A free function produces a Function entity"
    construct: "fn name() { ... }"
    produces: Function
    tested_by: [free_functions, visibility, async_functions]

  - id: E-FN-ASSOC
    description: "An associated function (no self) in impl block produces Function"
    construct: "impl Type { fn name() { ... } }"
    produces: Function
    condition: "function has no self parameter and does not return Self"
    tested_by: [methods]

  # ---------------------------------------------------------------------------
  # Methods
  # ---------------------------------------------------------------------------
  - id: E-METHOD-SELF
    description: "A function with self parameter produces Method"
    construct: "fn name(&self) { ... }"
    produces: Method
    condition: "function has self, &self, &mut self, or mut self parameter"
    tested_by: [methods, trait_impl]

  - id: E-METHOD-RETURNS-SELF
    description: "A function returning Self produces Method"
    construct: "fn new() -> Self { ... }"
    produces: Method
    condition: "function returns Self (constructor pattern)"
    divergence: |
      The Rust Reference defines methods as functions with a self parameter.
      We ALSO classify functions returning Self as methods because:
      1. They are conceptually instance-related (constructors, builders)
      2. Better search semantics ("find methods of Type" includes constructors)
    reference: "https://doc.rust-lang.org/reference/items/associated-items.html"
    tested_by: [builder_pattern]

  - id: E-METHOD-TRAIT-DEF
    description: "A method signature in a trait produces Method"
    construct: "trait T { fn method(&self); }"
    produces: Method
    tested_by: [trait_def]

  - id: E-METHOD-TRAIT-IMPL
    description: "A method in a trait impl produces Method"
    construct: "impl Trait for Type { fn method(&self) { ... } }"
    produces: Method
    tested_by: [trait_impl, multiple_trait_impls]

  # ---------------------------------------------------------------------------
  # Types
  # ---------------------------------------------------------------------------
  - id: E-STRUCT
    description: "A struct declaration produces a Struct entity"
    construct: "struct Name { ... }"
    produces: Struct
    tested_by: [structs, tuple_and_unit_structs, generic_structs]

  - id: E-ENUM
    description: "An enum declaration produces an Enum entity"
    construct: "enum Name { ... }"
    produces: Enum
    tested_by: [enums, complex_enums]

  # ---------------------------------------------------------------------------
  # Struct Fields and Enum Variants
  # ---------------------------------------------------------------------------
  - id: E-PROPERTY
    description: "A struct field produces a Property entity"
    construct: "field_name: Type"
    produces: Property
    note: "Property entities are children of their parent Struct/Union"
    tested_by: [structs, tuple_and_unit_structs, generic_structs]

  - id: E-ENUM-VARIANT
    description: "An enum variant produces an EnumVariant entity"
    construct: "VariantName or VariantName(T) or VariantName { field: T }"
    produces: EnumVariant
    note: "EnumVariant entities are children of their parent Enum"
    tested_by: [enums, complex_enums]

  - id: E-TRAIT
    description: "A trait declaration produces a Trait entity"
    construct: "trait Name { ... }"
    produces: Trait
    tested_by: [trait_def, supertraits]

  - id: E-TYPE-ALIAS
    description: "A type alias produces a TypeAlias entity"
    construct: "type Name = ...;"
    produces: TypeAlias
    tested_by: [type_aliases, type_alias_chains]

  - id: E-TYPE-ALIAS-ASSOC
    description: "An associated type in trait impl produces TypeAlias"
    construct: "impl Trait for Type { type Assoc = ...; }"
    produces: TypeAlias
    constraint: "Associated types can ONLY appear in trait impls, not inherent impls"
    reference: "https://doc.rust-lang.org/reference/items/associated-items.html"
    tested_by: [associated_types]

  # ---------------------------------------------------------------------------
  # Impl Blocks
  # ---------------------------------------------------------------------------
  - id: E-IMPL-INHERENT
    description: "An inherent impl block produces an ImplBlock entity"
    construct: "impl Type { ... }"
    produces: ImplBlock
    tested_by: [methods, multiple_impl_blocks]

  - id: E-IMPL-TRAIT
    description: "A trait impl block produces an ImplBlock entity"
    construct: "impl Trait for Type { ... }"
    produces: ImplBlock
    tested_by: [trait_impl, multiple_trait_impls, blanket_impl]

  # ---------------------------------------------------------------------------
  # Constants and Statics
  # ---------------------------------------------------------------------------
  - id: E-CONST
    description: "A const declaration produces a Constant entity"
    construct: "const NAME: Type = value;"
    produces: Constant
    note: "Constants are inlined at compile time and have no memory address"
    reference: "https://doc.rust-lang.org/reference/items/constant-items.html"
    tested_by: [constants]

  - id: E-STATIC
    description: "A static declaration produces a Static entity"
    construct: "static NAME: Type = value;"
    produces: Static
    note: "Statics have a fixed memory address and can be mutable (static mut)"
    reference: "https://doc.rust-lang.org/reference/items/static-items.html"
    tested_by: [statics]

  - id: E-CONST-ASSOC
    description: "An associated constant in trait or impl produces Constant"
    construct: "impl Type { const NAME: Type = value; }"
    produces: Constant
    note: "Can appear in traits (with or without default) and in impls"
    reference: "https://doc.rust-lang.org/reference/items/associated-items.html#associated-constants"
    tested_by: [associated_constants]

  # ---------------------------------------------------------------------------
  # Unions
  # ---------------------------------------------------------------------------
  - id: E-UNION
    description: "A union declaration produces a Union entity"
    construct: "union Name { ... }"
    produces: Union
    note: "Unions are similar to structs but all fields share the same memory"
    reference: "https://doc.rust-lang.org/reference/items/unions.html"
    tested_by: [unions]

  # ---------------------------------------------------------------------------
  # Extern Blocks
  # ---------------------------------------------------------------------------
  - id: E-EXTERN-BLOCK
    description: "An extern block produces an ExternBlock entity"
    construct: 'extern "C" { ... }'
    produces: ExternBlock
    note: "Contains FFI declarations for functions and statics from other languages"
    reference: "https://doc.rust-lang.org/reference/items/external-blocks.html"
    tested_by: [extern_blocks]

  - id: E-EXTERN-FN
    description: "A function declaration in extern block produces Function"
    construct: 'extern "C" { fn name(); }'
    produces: Function
    note: "FFI function declaration without body"
    tested_by: [extern_blocks]

  - id: E-EXTERN-STATIC
    description: "A static declaration in extern block produces Static"
    construct: 'extern "C" { static NAME: Type; }'
    produces: Static
    note: "FFI static declaration"
    tested_by: [extern_blocks]

  # ---------------------------------------------------------------------------
  # Macros
  # ---------------------------------------------------------------------------
  - id: E-MACRO-RULES
    description: "A macro_rules! declaration produces a Macro entity"
    construct: "macro_rules! name { ... }"
    produces: Macro
    tested_by: [macro_rules]


# =============================================================================
# VISIBILITY RULES
# =============================================================================
# Defines how visibility is determined for entities.
# Rules are evaluated in precedence order; first matching rule wins.

visibility_rules:

  # ---------------------------------------------------------------------------
  # Special cases (no visibility modifier allowed)
  # ---------------------------------------------------------------------------
  - id: V-IMPL-BLOCK
    description: "Impl blocks have no visibility (None)"
    applies_to: ImplBlock
    result: null  # None in Rust
    reason: "Rust syntax does not allow visibility modifiers on impl blocks"
    reference: "https://doc.rust-lang.org/reference/items/implementations.html"
    precedence: 1
    tested_by: [methods, trait_impl]

  - id: V-TRAIT-METHOD-DEF
    description: "Trait method definitions have no visibility (None)"
    applies_to: Method
    condition: "method is defined inside a trait (not trait impl)"
    result: null  # None in Rust
    reason: |
      Trait items are implicitly public (they inherit the trait's visibility).
      Visibility annotations are syntactically allowed but rejected during validation.
    reference: "https://doc.rust-lang.org/reference/items/traits.html"
    precedence: 2
    tested_by: [trait_def]

  # ---------------------------------------------------------------------------
  # Trait impl members (effectively public)
  # ---------------------------------------------------------------------------
  - id: V-TRAIT-IMPL-METHOD
    description: "Methods in trait impls are effectively Public"
    applies_to: Method
    condition: "method is inside `impl Trait for Type`"
    result: Public
    reason: |
      Trait impl items inherit visibility from the trait definition.
      Since trait items are implicitly public, trait impl items are also public.
      Visibility modifiers are not allowed on trait impl items.
    reference: "https://doc.rust-lang.org/reference/items/implementations.html"
    precedence: 3
    tested_by: [trait_impl, multiple_trait_impls]

  - id: V-TRAIT-IMPL-ASSOC-TYPE
    description: "Associated types in trait impls are effectively Public"
    applies_to: TypeAlias
    condition: "type alias is inside `impl Trait for Type`"
    result: Public
    reason: "Trait impl items inherit visibility from the trait (implicitly public)"
    reference: "https://doc.rust-lang.org/reference/items/implementations.html"
    precedence: 3
    tested_by: [associated_types]

  - id: V-TRAIT-IMPL-CONST
    description: "Associated constants in trait impls are effectively Public"
    applies_to: Constant
    condition: "constant is inside `impl Trait for Type`"
    result: Public
    reason: "Trait impl items inherit visibility from the trait (implicitly public)"
    reference: "https://doc.rust-lang.org/reference/items/implementations.html"
    precedence: 3

  # ---------------------------------------------------------------------------
  # Standard visibility modifiers
  # Reference: https://doc.rust-lang.org/reference/visibility-and-privacy.html
  # ---------------------------------------------------------------------------
  - id: V-PUB
    description: "pub modifier results in Public visibility"
    applies_to: "*"
    condition: "has `pub` modifier without restriction"
    result: Public
    precedence: 10
    tested_by: [visibility, free_functions, structs]

  - id: V-PUB-CRATE
    description: "pub(crate) modifier results in Internal visibility"
    applies_to: "*"
    condition: "has `pub(crate)` modifier"
    result: Internal
    note: "Visible within the current crate only"
    precedence: 10
    tested_by: [visibility]

  - id: V-PUB-SUPER
    description: "pub(super) modifier results in Internal visibility"
    applies_to: "*"
    condition: "has `pub(super)` modifier"
    result: Internal
    note: "Visible to parent module; equivalent to pub(in super)"
    precedence: 10

  - id: V-PUB-IN-PATH
    description: "pub(in path) modifier results in Internal visibility"
    applies_to: "*"
    condition: "has `pub(in path::to::module)` modifier"
    result: Internal
    note: "Visible within the specified ancestor module path"
    precedence: 10

  - id: V-PUB-SELF
    description: "pub(self) modifier results in Private visibility"
    applies_to: "*"
    condition: "has `pub(self)` modifier"
    result: Private
    note: "Equivalent to no visibility modifier; visible only to current module"
    reference: "https://doc.rust-lang.org/reference/visibility-and-privacy.html"
    precedence: 10

  # ---------------------------------------------------------------------------
  # Inherited visibility
  # ---------------------------------------------------------------------------
  - id: V-ENUM-VARIANT
    description: "Enum variants inherit visibility from parent enum"
    applies_to: EnumVariant
    condition: "variant is inside a pub enum"
    result: "inherits from parent"
    reason: |
      Enum variants in a pub enum are public by default.
      This is one of only two exceptions to the default-private rule.
    reference: "https://doc.rust-lang.org/reference/visibility-and-privacy.html"
    precedence: 5
    tested_by: [enums]

  - id: V-PROPERTY
    description: "Struct fields have explicit visibility or default to private"
    applies_to: Property
    result: "explicit visibility or Private"
    reason: |
      Struct fields can have visibility modifiers (pub, pub(crate), etc.)
      or default to private (visible only within the module).
    reference: "https://doc.rust-lang.org/reference/visibility-and-privacy.html"
    precedence: 5
    tested_by: [structs]

  - id: V-PRIVATE
    description: "No visibility modifier results in Private visibility"
    applies_to: "*"
    condition: "no visibility modifier present"
    result: Private
    note: "Accessible only by the current module and its descendants"
    precedence: 100  # lowest precedence (default)
    tested_by: [visibility]


# =============================================================================
# QUALIFIED NAME RULES
# =============================================================================
# Defines how qualified names are constructed for entities.

qualified_name_rules:

  # ---------------------------------------------------------------------------
  # Basic qualified names
  # ---------------------------------------------------------------------------
  - id: Q-CRATE-ROOT
    description: "Crate root module is named after the package"
    pattern: "{crate_name}"
    example: "test_crate"
    divergence: |
      The Rust Reference states that the crate root module does not have a name,
      but can be referred to with path qualifiers like `crate::`.
      We use the package name for cross-crate searchability.
    reference: "https://doc.rust-lang.org/reference/names.html"
    tested_by: [basic_mod]

  - id: Q-MODULE
    description: "Modules are qualified under their parent module"
    pattern: "{parent}::{name}"
    examples:
      - "test_crate::foo"  # direct child of crate root
      - "test_crate::foo::bar"  # nested module (grandchild of crate root)
    note: "{parent} is the full path of the parent module, recursively building the path"
    tested_by: [basic_mod, deep_module_nesting]

  - id: Q-ITEM
    description: "Top-level items are qualified under their full module path"
    pattern: "{module}::{name}"
    applies_to: [Function, Struct, Enum, Trait, Constant, TypeAlias, Macro]
    examples:
      - "test_crate::MyStruct"  # item at crate root
      - "test_crate::submod::MyStruct"  # item in submodule
      - "test_crate::a::b::MyStruct"  # item in nested submodule
    note: "{module} is the full module path from crate root, not just the immediate parent"
    tested_by: [structs, free_functions, deep_module_nesting]

  # ---------------------------------------------------------------------------
  # Impl block qualified names
  # ---------------------------------------------------------------------------
  - id: Q-IMPL-INHERENT
    description: "Inherent impl blocks include 'impl' keyword"
    pattern: "{module}::impl {type_fqn}"
    examples:
      - "test_crate::impl test_crate::Foo"  # impl in crate root
      - "test_crate::submod::impl test_crate::submod::Foo"  # impl in submodule
    note: "{module} is where the impl is defined; {type_fqn} is the type's full path"
    divergence: |
      The Rust Reference states that implementations do not have canonical paths.
      We assign qualified names to impl blocks for searchability and to establish
      containment relationships with their associated items.
    reference: "https://doc.rust-lang.org/reference/paths.html#canonical-paths"
    tested_by: [methods]

  - id: Q-IMPL-TRAIT
    description: "Trait impl blocks use angle bracket notation"
    pattern: "{module}::<{type_fqn} as {trait_fqn}>"
    examples:
      - "test_crate::<test_crate::MyHandler as test_crate::Handler>"
      - "test_crate::submod::<test_crate::submod::Foo as test_crate::Handler>"  # impl in submodule
    note: "{module} is where the impl is defined; {type_fqn} and {trait_fqn} are full paths"
    divergence: |
      The Rust Reference states that implementations do not have canonical paths.
      We assign qualified names to impl blocks for searchability and to establish
      containment relationships with their associated items.
    reference: "https://doc.rust-lang.org/reference/paths.html#canonical-paths"
    tested_by: [trait_impl]

  # ---------------------------------------------------------------------------
  # Impl member qualified names
  # ---------------------------------------------------------------------------
  - id: Q-INHERENT-METHOD
    description: "Inherent impl methods use angle bracket UFCS format"
    pattern: "<{type_fqn}>::{name}"
    examples:
      - "<test_crate::Foo>::method"  # method on type at crate root
      - "<test_crate::submod::Foo>::method"  # method on type in submodule
    note: "Matches Rust's canonical path format for inherent impl items"
    reference: "https://doc.rust-lang.org/reference/paths.html#canonical-paths"
    tested_by: [methods]

  - id: Q-TRAIT-IMPL-METHOD
    description: "Trait impl methods use UFCS format without module prefix"
    pattern: "<{type_fqn} as {trait_fqn}>::{name}"
    examples:
      - "<test_crate::MyHandler as test_crate::Handler>::handle"
      - "<test_crate::submod::Foo as test_crate::Handler>::process"  # type in submodule
    note: "No module prefix on the angle bracket expression; type/trait FQNs include full paths"
    tested_by: [trait_impl]

  - id: Q-ASSOC-TYPE
    description: "Associated types use angle bracket UFCS format"
    pattern: "<{type_fqn} as {trait_fqn}>::{name}"
    examples:
      - "<test_crate::Counter as test_crate::Iterator>::Item"
      - "<test_crate::submod::Counter as test_crate::Iterator>::Item"
    note: "Uses UFCS format since associated types only exist in trait impls"
    reference: "https://doc.rust-lang.org/reference/paths.html#canonical-paths"
    tested_by: [associated_types]

  # ---------------------------------------------------------------------------
  # Trait method definitions
  # ---------------------------------------------------------------------------
  - id: Q-TRAIT-METHOD-DEF
    description: "Trait method definitions are qualified under the trait"
    pattern: "{trait_fqn}::{name}"
    examples:
      - "test_crate::Handler::handle"  # trait at crate root
      - "test_crate::submod::Handler::handle"  # trait in submodule
    note: "{trait_fqn} includes full module path to the trait"
    tested_by: [trait_def]

  # ---------------------------------------------------------------------------
  # Struct field and enum variant qualified names
  # ---------------------------------------------------------------------------
  - id: Q-PROPERTY
    description: "Struct/union fields are qualified under their parent type"
    pattern: "{struct_fqn}::{field_name}"
    examples:
      - "test_crate::Config::name"  # field on struct at crate root
      - "test_crate::submod::Point::x"  # field on struct in submodule
      - "test_crate::Point::0"  # tuple struct field (numeric name)
    tested_by: [structs, tuple_and_unit_structs]

  - id: Q-ENUM-VARIANT
    description: "Enum variants are qualified under their parent enum"
    pattern: "{enum_fqn}::{variant_name}"
    examples:
      - "test_crate::Status::Active"  # variant on enum at crate root
      - "test_crate::submod::Color::Red"  # variant on enum in submodule
    tested_by: [enums, complex_enums]


# =============================================================================
# RELATIONSHIP RULES
# =============================================================================
# Defines what relationships are created between entities.

relationship_rules:

  # ---------------------------------------------------------------------------
  # Containment (structural hierarchy)
  # ---------------------------------------------------------------------------
  - id: R-CONTAINS-MODULE
    description: "Parent module CONTAINS child modules"
    kind: Contains
    from: Module
    to: Module
    tested_by: [basic_mod, deep_module_nesting]

  - id: R-CONTAINS-ITEM
    description: "Module CONTAINS top-level items"
    kind: Contains
    from: Module
    to: [Function, Struct, Enum, Union, Trait, Constant, Static, TypeAlias, Macro, ImplBlock, ExternBlock]
    tested_by: [free_functions, structs, trait_def, unions, statics, extern_blocks]

  - id: R-CONTAINS-TRAIT-MEMBER
    description: "Trait CONTAINS its method definitions"
    kind: Contains
    from: Trait
    to: Method
    tested_by: [trait_def]

  - id: R-CONTAINS-IMPL-MEMBER
    description: "ImplBlock CONTAINS its methods and associated items"
    kind: Contains
    from: ImplBlock
    to: [Method, Function, Constant]
    tested_by: [methods, trait_impl]

  - id: R-CONTAINS-ASSOC-TYPE
    description: "Type CONTAINS its associated types (not impl block)"
    kind: Contains
    from: Struct
    to: TypeAlias
    condition: "associated type from trait impl"
    note: "Associated types are children of the type, not the impl block"
    tested_by: [associated_types]

  - id: R-CONTAINS-EXTERN-ITEM
    description: "ExternBlock CONTAINS its FFI declarations"
    kind: Contains
    from: ExternBlock
    to: [Function, Static]
    note: "Extern blocks contain function and static declarations for FFI"
    tested_by: [extern_blocks]

  - id: R-CONTAINS-PROPERTY
    description: "Struct/Union CONTAINS its fields"
    kind: Contains
    from: [Struct, Union]
    to: Property
    note: "Property entities represent struct/union fields as first-class entities"
    tested_by: [structs, tuple_and_unit_structs, unions]

  - id: R-CONTAINS-ENUM-VARIANT
    description: "Enum CONTAINS its variants"
    kind: Contains
    from: Enum
    to: EnumVariant
    note: "EnumVariant entities represent enum variants as first-class entities"
    tested_by: [enums, complex_enums]

  # ---------------------------------------------------------------------------
  # Trait relationships
  # ---------------------------------------------------------------------------
  - id: R-IMPLEMENTS
    description: "Trait impl block IMPLEMENTS the trait"
    kind: Implements
    from: ImplBlock
    to: Trait
    condition: "impl block is `impl Trait for Type`"
    tested_by: [trait_impl, multiple_trait_impls]

  - id: R-EXTENDS-INTERFACE
    description: "Subtrait EXTENDS_INTERFACE supertrait"
    kind: ExtendsInterface
    from: Trait
    to: Trait
    condition: "trait has supertrait bounds (trait Sub: Super)"
    tested_by: [supertraits]

  # ---------------------------------------------------------------------------
  # Call relationships
  # ---------------------------------------------------------------------------
  - id: R-CALLS-FUNCTION
    description: "Function/Method CALLS another function/method"
    kind: Calls
    from: [Function, Method]
    to: [Function, Method]
    condition: "function call expression in body"
    tested_by: [free_functions, cross_module_calls, recursive_calls]

  # ---------------------------------------------------------------------------
  # Type usage relationships
  # ---------------------------------------------------------------------------
  - id: R-USES-TYPE
    description: "Entity USES a type it references"
    kind: Uses
    from: [Function, Method, Struct, TypeAlias, Property, EnumVariant]
    to: [Struct, Enum, Trait, TypeAlias]
    condition: "type appears in signature, field, or type expression"
    note: "Property and EnumVariant entities have their own USES relationships for field types"
    tested_by: [generic_bounds_resolution, structs, complex_enums]

  # ---------------------------------------------------------------------------
  # Import relationships
  # ---------------------------------------------------------------------------
  - id: R-IMPORTS
    description: "Module IMPORTS items via use statements"
    kind: Imports
    from: Module
    to: [Function, Struct, Enum, Union, Trait, Constant, Static, TypeAlias, Macro, Module]
    condition: "use statement brings item into scope"
    tested_by: [use_imports, reexports]


# =============================================================================
# METADATA RULES
# =============================================================================
# Defines what metadata is captured for entities.

metadata_rules:

  # ---------------------------------------------------------------------------
  # Function/Method metadata
  # ---------------------------------------------------------------------------
  - id: M-FN-ASYNC
    description: "Async functions have is_async=true"
    applies_to: [Function, Method]
    field: is_async
    condition: "function has `async` keyword"
    tested_by: [async_functions]

  - id: M-FN-CONST
    description: "Const functions have is_const=true"
    applies_to: [Function, Method]
    field: is_const
    condition: "function has `const` keyword"

  - id: M-FN-UNSAFE
    description: "Unsafe functions have is_unsafe=true"
    applies_to: [Function, Method]
    field: is_unsafe
    condition: "function has `unsafe` keyword"

  # ---------------------------------------------------------------------------
  # Static metadata
  # ---------------------------------------------------------------------------
  - id: M-STATIC-MUTABILITY
    description: "Static items track mutability"
    applies_to: Static
    field: is_mutable
    condition: "static has `mut` keyword (static mut)"
    note: "Mutable statics require unsafe to access"
    reference: "https://doc.rust-lang.org/reference/items/static-items.html#mutable-statics"
    tested_by: [statics]

  # ---------------------------------------------------------------------------
  # Trait constraints
  # ---------------------------------------------------------------------------
  - id: M-TRAIT-NO-CONST-FN
    description: "Trait functions cannot be const"
    applies_to: Method
    condition: "method is defined inside a trait"
    constraint: "const keyword not allowed"
    reference: "https://doc.rust-lang.org/reference/items/traits.html"
    note: "This is a validation rule, not metadata extraction"

  # ---------------------------------------------------------------------------
  # Generic metadata
  # ---------------------------------------------------------------------------
  - id: M-GENERIC
    description: "Generic items have is_generic=true and generic_params list"
    applies_to: [Function, Method, Struct, Enum, Trait, TypeAlias, ImplBlock]
    fields: [is_generic, generic_params]
    condition: "item has type parameters"
    tested_by: [generic_structs, generic_trait, const_generics]

  - id: M-LIFETIMES
    description: "Items with lifetime parameters include them in generic_params"
    applies_to: [Function, Method, Struct, Enum, Trait, ImplBlock]
    field: generic_params
    condition: "item has lifetime parameters"
    tested_by: [lifetimes]

  # ---------------------------------------------------------------------------
  # Struct/Enum child entities (previously JSON metadata)
  # ---------------------------------------------------------------------------
  # NOTE: Struct fields and enum variants are now extracted as first-class
  # Property and EnumVariant entities respectively. They are no longer stored
  # as JSON in attributes. See entity rules E-PROPERTY and E-ENUM-VARIANT.

  - id: M-PROPERTY-TYPE
    description: "Property entities include field type in content"
    applies_to: Property
    field: content
    format: "Field declaration as string (e.g., 'pub name: String')"
    note: "Type references are captured in uses_types for USES relationships"
    tested_by: [structs, tuple_and_unit_structs]

  - id: M-ENUM-VARIANT-VALUE
    description: "EnumVariant entities may include discriminant value"
    applies_to: EnumVariant
    field: attributes.discriminant
    format: "Integer value if explicit discriminant"
    note: "Only present for variants with explicit discriminant (e.g., Foo = 1)"
    tested_by: [enums]

  # ---------------------------------------------------------------------------
  # Trait metadata
  # ---------------------------------------------------------------------------
  - id: M-TRAIT-BOUNDS
    description: "Traits with supertraits include bounds"
    applies_to: Trait
    field: attributes.bounds
    format: "Supertrait names joined with ' + '"
    tested_by: [supertraits]

  - id: M-TRAIT-METHODS
    description: "Traits include method names"
    applies_to: Trait
    field: attributes.methods
    format: "Comma-separated method names"
    tested_by: [trait_def]

  - id: M-TRAIT-ASSOC-TYPES
    description: "Traits include associated type names"
    applies_to: Trait
    field: attributes.associated_types
    format: "Comma-separated type names"
    tested_by: [associated_types]

  # ---------------------------------------------------------------------------
  # Type alias metadata
  # ---------------------------------------------------------------------------
  - id: M-TYPE-ALIAS-TARGET
    description: "Type aliases include the aliased type"
    applies_to: TypeAlias
    field: attributes.aliased_type
    tested_by: [type_aliases]


# =============================================================================
# EXTRACTION HINTS
# =============================================================================
# These hints drive code generation for entity handlers. They extend the
# declarative rules above with implementation details needed for extraction.
#
# Key design principles:
# - Queries use tree-sitter captures to extract AST components (no string parsing)
# - Query-level scoping distinguishes contexts (inherent impl vs trait impl vs trait def)
# - Engine provides contextual placeholders: {crate}, {module_path}, {scope}
# - Import resolution is deferred to outbox-processor, not extraction time

extraction_hints:

  # ---------------------------------------------------------------------------
  # Tree-sitter Queries
  # ---------------------------------------------------------------------------
  #
  # Queries are scoped to specific contexts using parent node matching.
  # This eliminates the need for runtime disambiguation.

  queries:

    # --- Module queries ---

    MODULE_DECLARATION:
      description: "Module declarations (mod foo;)"
      capture: "module"
      query: |
        (mod_item
          name: (identifier) @name
          body: (declaration_list)? @body) @module

    # --- Function queries (free functions, not in impl/trait) ---

    FUNCTION_FREE:
      description: "Free functions at module level"
      capture: "function"
      query: |
        (function_item
          name: (identifier) @name
          parameters: (parameters) @params
          return_type: (_)? @return_type
          body: (block) @body) @function

    # --- Impl block queries ---

    IMPL_INHERENT:
      description: "Inherent impl blocks (impl Type)"
      capture: "impl"
      query: |
        (impl_item
          type_parameters: (type_parameters)? @type_params
          type: [
            (type_identifier) @impl_type_name
            (generic_type
              type: (type_identifier) @impl_type_name
              type_arguments: (type_arguments) @impl_type_args)
            (scoped_type_identifier
              path: (_) @impl_type_path
              name: (type_identifier) @impl_type_name)
          ]
          body: (declaration_list) @body) @impl
        (#not-has-child? @impl trait)

    IMPL_TRAIT:
      description: "Trait impl blocks (impl Trait for Type)"
      capture: "impl"
      query: |
        (impl_item
          type_parameters: (type_parameters)? @type_params
          trait: [
            (type_identifier) @trait_name
            (generic_type
              type: (type_identifier) @trait_name
              type_arguments: (type_arguments) @trait_type_args)
            (scoped_type_identifier
              path: (_) @trait_path
              name: (type_identifier) @trait_name)
          ]
          type: [
            (type_identifier) @impl_type_name
            (generic_type
              type: (type_identifier) @impl_type_name
              type_arguments: (type_arguments) @impl_type_args)
            (scoped_type_identifier
              path: (_) @impl_type_path
              name: (type_identifier) @impl_type_name)
          ]
          body: (declaration_list) @body) @impl

    # --- Method queries (scoped to impl blocks) ---

    METHOD_IN_INHERENT_IMPL:
      description: "Methods with self parameter in inherent impl"
      capture: "method"
      query: |
        (impl_item
          type: [
            (type_identifier) @impl_type_name
            (generic_type type: (type_identifier) @impl_type_name)
            (scoped_type_identifier name: (type_identifier) @impl_type_name)
          ]
          body: (declaration_list
            (function_item
              name: (identifier) @name
              parameters: (parameters
                (self_parameter) @self_param)
              return_type: (_)? @return_type
              body: (block) @body) @method)) @impl
        (#not-has-child? @impl trait)

    METHOD_RETURNS_SELF_IN_INHERENT_IMPL:
      description: "Constructor methods returning Self in inherent impl"
      capture: "method"
      query: |
        (impl_item
          type: [
            (type_identifier) @impl_type_name
            (generic_type type: (type_identifier) @impl_type_name)
            (scoped_type_identifier name: (type_identifier) @impl_type_name)
          ]
          body: (declaration_list
            (function_item
              name: (identifier) @name
              parameters: (parameters) @params
              return_type: (type_identifier) @return_type
              body: (block) @body) @method)) @impl
        (#not-has-child? @impl trait)
        (#not-has-child? @params self_parameter)
        (#eq? @return_type "Self")

    ASSOCIATED_FUNCTION_IN_INHERENT_IMPL:
      description: "Associated functions (no self, not returning Self) in inherent impl"
      capture: "function"
      query: |
        (impl_item
          type: [
            (type_identifier) @impl_type_name
            (generic_type type: (type_identifier) @impl_type_name)
            (scoped_type_identifier name: (type_identifier) @impl_type_name)
          ]
          body: (declaration_list
            (function_item
              name: (identifier) @name
              parameters: (parameters) @params
              return_type: (_)? @return_type
              body: (block) @body) @function)) @impl
        (#not-has-child? @impl trait)
        (#not-has-child? @params self_parameter)
        (#not-eq? @return_type "Self")

    METHOD_IN_TRAIT_IMPL:
      description: "Methods in trait impl blocks"
      capture: "method"
      query: |
        (impl_item
          trait: [
            (type_identifier) @trait_name
            (generic_type type: (type_identifier) @trait_name)
            (scoped_type_identifier name: (type_identifier) @trait_name)
          ]
          type: [
            (type_identifier) @impl_type_name
            (generic_type type: (type_identifier) @impl_type_name)
            (scoped_type_identifier name: (type_identifier) @impl_type_name)
          ]
          body: (declaration_list
            (function_item
              name: (identifier) @name
              parameters: (parameters) @params
              return_type: (_)? @return_type
              body: (block) @body) @method))

    # --- Trait definition queries ---

    TRAIT:
      description: "Trait definitions"
      capture: "trait"
      query: |
        (trait_item
          name: (type_identifier) @name
          type_parameters: (type_parameters)? @type_params
          bounds: (trait_bounds)? @bounds
          body: (declaration_list) @body) @trait

    METHOD_IN_TRAIT_DEF:
      description: "Method signatures in trait definitions"
      capture: "method"
      query: |
        (trait_item
          name: (type_identifier) @trait_name
          body: (declaration_list
            (function_signature_item
              name: (identifier) @name
              parameters: (parameters) @params
              return_type: (_)? @return_type) @method))

    METHOD_WITH_DEFAULT_IN_TRAIT_DEF:
      description: "Methods with default implementation in trait definitions"
      capture: "method"
      query: |
        (trait_item
          name: (type_identifier) @trait_name
          body: (declaration_list
            (function_item
              name: (identifier) @name
              parameters: (parameters) @params
              return_type: (_)? @return_type
              body: (block) @body) @method))

    # --- Type definition queries ---

    STRUCT:
      description: "Struct definitions"
      capture: "struct"
      query: |
        (struct_item
          name: (type_identifier) @name
          type_parameters: (type_parameters)? @type_params
          body: [
            (field_declaration_list) @fields
            (ordered_field_declaration_list) @tuple_fields
          ]?) @struct

    STRUCT_FIELD:
      description: "Named struct fields"
      capture: "field"
      query: |
        (field_declaration_list
          (field_declaration
            name: (field_identifier) @name
            type: (_) @field_type) @field)

    # Note: Tuple struct fields are positional and don't have field_declaration nodes
    # They would need special handling with PositionalIndex name strategy
    # For now, we skip individual tuple field extraction

    ENUM:
      description: "Enum definitions"
      capture: "enum"
      query: |
        (enum_item
          name: (type_identifier) @name
          type_parameters: (type_parameters)? @type_params
          body: (enum_variant_list) @variants) @enum

    ENUM_VARIANT:
      description: "Enum variants"
      capture: "variant"
      query: |
        (enum_item
          name: (type_identifier) @enum_name
          body: (enum_variant_list
            (enum_variant
              name: (identifier) @name
              body: [
                (field_declaration_list) @fields
                (ordered_field_declaration_list) @tuple_fields
              ]?
              value: (_)? @discriminant) @variant))

    UNION:
      description: "Union definitions"
      capture: "union"
      query: |
        (union_item
          name: (type_identifier) @name
          body: (field_declaration_list) @fields) @union

    UNION_FIELD:
      description: "Union fields"
      capture: "field"
      query: |
        (union_item
          name: (type_identifier) @union_name
          body: (field_declaration_list
            (field_declaration
              name: (field_identifier) @name
              type: (_) @field_type) @field))

    TYPE_ALIAS:
      description: "Type alias definitions"
      capture: "type_alias"
      query: |
        (type_item
          name: (type_identifier) @name
          type_parameters: (type_parameters)? @type_params
          type: (_) @aliased_type) @type_alias

    ASSOCIATED_TYPE_IN_TRAIT_IMPL:
      description: "Associated types in trait impl blocks"
      capture: "type_alias"
      query: |
        (impl_item
          trait: [
            (type_identifier) @trait_name
            (generic_type type: (type_identifier) @trait_name)
            (scoped_type_identifier name: (type_identifier) @trait_name)
          ]
          type: [
            (type_identifier) @impl_type_name
            (generic_type type: (type_identifier) @impl_type_name)
            (scoped_type_identifier name: (type_identifier) @impl_type_name)
          ]
          body: (declaration_list
            (type_item
              name: (type_identifier) @name
              type: (_) @aliased_type) @type_alias))

    # --- Constant and static queries ---

    CONST:
      description: "Constant definitions at module level"
      capture: "const"
      query: |
        (const_item
          name: (identifier) @name
          type: (_) @const_type
          value: (_) @value) @const

    CONST_IN_INHERENT_IMPL:
      description: "Associated constants in inherent impl blocks"
      capture: "const"
      query: |
        (impl_item
          type: [
            (type_identifier) @impl_type_name
            (generic_type type: (type_identifier) @impl_type_name)
            (scoped_type_identifier name: (type_identifier) @impl_type_name)
          ]
          body: (declaration_list
            (const_item
              name: (identifier) @name
              type: (_) @const_type
              value: (_) @value) @const)) @impl
        (#not-has-child? @impl trait)

    CONST_IN_TRAIT_IMPL:
      description: "Associated constants in trait impl blocks"
      capture: "const"
      query: |
        (impl_item
          trait: [
            (type_identifier) @trait_name
            (generic_type type: (type_identifier) @trait_name)
            (scoped_type_identifier name: (type_identifier) @trait_name)
          ]
          type: [
            (type_identifier) @impl_type_name
            (generic_type type: (type_identifier) @impl_type_name)
            (scoped_type_identifier name: (type_identifier) @impl_type_name)
          ]
          body: (declaration_list
            (const_item
              name: (identifier) @name
              type: (_) @const_type
              value: (_) @value) @const))

    STATIC:
      description: "Static definitions"
      capture: "static"
      query: |
        (static_item
          name: (identifier) @name
          type: (_) @static_type
          value: (_) @value) @static

    # --- Extern block queries ---

    EXTERN_BLOCK:
      description: "Extern block declarations"
      capture: "extern_block"
      query: |
        (foreign_mod_item
          (extern_modifier
            (string_literal)? @abi)
          body: (declaration_list) @body) @extern_block

    EXTERN_FUNCTION:
      description: "Function declarations in extern blocks"
      capture: "function"
      query: |
        (foreign_mod_item
          body: (declaration_list
            (function_signature_item
              name: (identifier) @name
              parameters: (parameters) @params
              return_type: (_)? @return_type) @function))

    EXTERN_STATIC:
      description: "Static declarations in extern blocks"
      capture: "static"
      query: |
        (foreign_mod_item
          body: (declaration_list
            (static_item
              name: (identifier) @name
              type: (_) @static_type) @static))

    # --- Macro queries ---

    MACRO_RULES:
      description: "macro_rules! definitions"
      capture: "macro"
      query: |
        (macro_definition
          name: (identifier) @name) @macro

  # ---------------------------------------------------------------------------
  # Extractors
  # ---------------------------------------------------------------------------
  # Shared extraction functions for metadata and relationships.
  # These are referenced by handlers and can be reused across entity types.

  extractors:

    function_metadata:
      description: "Extract function/method metadata"
      metadata_fields:
        - is_async: "Check for async keyword"
        - is_const: "Check for const keyword"
        - is_unsafe: "Check for unsafe keyword"
        - is_generic: "Check for type_parameters"
        - generic_params: "Extract type parameter names"

    struct_metadata:
      description: "Extract struct metadata"
      metadata_fields:
        - is_generic: "Check for type_parameters"
        - generic_params: "Extract type parameter names"
        - is_tuple_struct: "Check for ordered_field_declaration_list"
        - is_unit_struct: "Check for no body"

    enum_metadata:
      description: "Extract enum metadata"
      metadata_fields:
        - is_generic: "Check for type_parameters"
        - generic_params: "Extract type parameter names"

    trait_metadata:
      description: "Extract trait metadata"
      metadata_fields:
        - is_generic: "Check for type_parameters"
        - generic_params: "Extract type parameter names"
        - bounds: "Extract supertrait bounds"

    static_metadata:
      description: "Extract static metadata"
      metadata_fields:
        - is_mutable: "Check for mutable_specifier"

    extract_function_relationships:
      description: "Extract function calls and type usages from body"
      relationship_fields:
        - calls: "Function/method calls in body"
        - uses_types: "Type references in signature"

    extract_type_relationships:
      description: "Extract type usage relationships"
      relationship_fields:
        - uses_types: "Types referenced in definition"

    extract_trait_relationships:
      description: "Extract trait relationships"
      relationship_fields:
        - extends: "Supertrait bounds"

    extract_impl_relationships:
      description: "Extract impl block relationships"
      relationship_fields:
        - implements: "Trait being implemented"

  # ---------------------------------------------------------------------------
  # Handlers
  # ---------------------------------------------------------------------------
  # Handler configurations that wire entity rules to queries and extractors.
  #
  # Qualified name templates use:
  # - Engine-provided: {crate}, {module_path}, {scope}
  # - Query captures: {name}, {impl_type_name}, {trait_name}, etc.

  handlers:

    # --- Module handlers ---

    Module:
      entity_rule: E-MOD-DECL
      query: MODULE_DECLARATION
      capture: "module"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"

    CrateRoot:
      entity_rule: E-MOD-CRATE
      name_strategy: crate_name
      qualified_name_template: "{crate}"

    # --- Free function handlers ---

    FreeFunction:
      entity_rule: E-FN-FREE
      query: FUNCTION_FREE
      capture: "function"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"
      metadata: function_metadata
      relationships: extract_function_relationships

    # --- Impl block handlers ---

    ImplInherent:
      entity_rule: E-IMPL-INHERENT
      query: IMPL_INHERENT
      capture: "impl"
      name_strategy: template
      name_template: "impl {impl_type_name}"
      qualified_name_template: "{scope}::impl {impl_type_name}"

    ImplTrait:
      entity_rule: E-IMPL-TRAIT
      query: IMPL_TRAIT
      capture: "impl"
      name_strategy: template
      name_template: "<{impl_type_name} as {trait_name}>"
      # Note: Uses just the fully-qualified type and trait names, no module prefix.
      # This ensures methods contained by this impl block share the same prefix.
      qualified_name_template: "<{impl_type_name} as {trait_name}>"
      relationships: extract_impl_relationships

    # --- Method handlers (in inherent impl) ---

    MethodInInherentImpl:
      entity_rule: E-METHOD-SELF
      query: METHOD_IN_INHERENT_IMPL
      capture: "method"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"
      metadata: function_metadata
      relationships: extract_function_relationships

    MethodReturnsSelfInInherentImpl:
      entity_rule: E-METHOD-RETURNS-SELF
      query: METHOD_RETURNS_SELF_IN_INHERENT_IMPL
      capture: "method"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"
      metadata: function_metadata
      relationships: extract_function_relationships

    AssociatedFunctionInInherentImpl:
      entity_rule: E-FN-ASSOC
      query: ASSOCIATED_FUNCTION_IN_INHERENT_IMPL
      capture: "function"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"
      metadata: function_metadata
      relationships: extract_function_relationships

    # --- Method handlers (in trait impl) ---

    MethodInTraitImpl:
      entity_rule: E-METHOD-TRAIT-IMPL
      query: METHOD_IN_TRAIT_IMPL
      capture: "method"
      name_strategy: capture
      qualified_name_template: "<{impl_type_name} as {trait_name}>::{name}"
      visibility_override: Public
      metadata: function_metadata
      relationships: extract_function_relationships

    # --- Method handlers (in trait definition) ---

    MethodInTraitDef:
      entity_rule: E-METHOD-TRAIT-DEF
      query: METHOD_IN_TRAIT_DEF
      capture: "method"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"
      visibility_override: null  # None - inherits from trait
      metadata: function_metadata

    MethodWithDefaultInTraitDef:
      entity_rule: E-METHOD-TRAIT-DEF
      query: METHOD_WITH_DEFAULT_IN_TRAIT_DEF
      capture: "method"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"
      visibility_override: null
      metadata: function_metadata
      relationships: extract_function_relationships

    # --- Type handlers ---

    Struct:
      entity_rule: E-STRUCT
      query: STRUCT
      capture: "struct"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"
      metadata: struct_metadata
      relationships: extract_type_relationships

    StructField:
      entity_rule: E-PROPERTY
      query: STRUCT_FIELD
      capture: "field"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"

    # TupleStructField handler removed - tuple fields need special handling
    # since ordered_field_declaration_list doesn't contain field_declaration nodes

    Enum:
      entity_rule: E-ENUM
      query: ENUM
      capture: "enum"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"
      metadata: enum_metadata

    EnumVariant:
      entity_rule: E-ENUM-VARIANT
      query: ENUM_VARIANT
      capture: "variant"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"

    Union:
      entity_rule: E-UNION
      query: UNION
      capture: "union"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"

    UnionField:
      entity_rule: E-PROPERTY
      query: UNION_FIELD
      capture: "field"
      name_strategy: capture
      qualified_name_template: "{scope}::{union_name}::{name}"

    Trait:
      entity_rule: E-TRAIT
      query: TRAIT
      capture: "trait"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"
      metadata: trait_metadata
      relationships: extract_trait_relationships

    TypeAlias:
      entity_rule: E-TYPE-ALIAS
      query: TYPE_ALIAS
      capture: "type_alias"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"

    AssociatedTypeInTraitImpl:
      entity_rule: E-TYPE-ALIAS-ASSOC
      query: ASSOCIATED_TYPE_IN_TRAIT_IMPL
      capture: "type_alias"
      name_strategy: capture
      qualified_name_template: "<{impl_type_name} as {trait_name}>::{name}"
      visibility_override: Public

    # --- Constant and static handlers ---

    Const:
      entity_rule: E-CONST
      query: CONST
      capture: "const"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"

    ConstInInherentImpl:
      entity_rule: E-CONST-ASSOC
      query: CONST_IN_INHERENT_IMPL
      capture: "const"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"

    ConstInTraitImpl:
      entity_rule: E-CONST-ASSOC
      query: CONST_IN_TRAIT_IMPL
      capture: "const"
      name_strategy: capture
      qualified_name_template: "<{impl_type_name} as {trait_name}>::{name}"
      visibility_override: Public

    Static:
      entity_rule: E-STATIC
      query: STATIC
      capture: "static"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"
      metadata: static_metadata

    # --- Extern block handlers ---

    ExternBlock:
      entity_rule: E-EXTERN-BLOCK
      query: EXTERN_BLOCK
      capture: "extern_block"
      name_strategy: template
      name_template: 'extern "{abi}"'
      qualified_name_template: '{scope}::extern "{abi}"'

    ExternFunction:
      entity_rule: E-EXTERN-FN
      query: EXTERN_FUNCTION
      capture: "function"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"
      visibility_override: Public

    ExternStatic:
      entity_rule: E-EXTERN-STATIC
      query: EXTERN_STATIC
      capture: "static"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"
      visibility_override: Public

    # --- Macro handlers ---

    MacroRules:
      entity_rule: E-MACRO-RULES
      query: MACRO_RULES
      capture: "macro"
      name_strategy: capture
      qualified_name_template: "{scope}::{name}"


# =============================================================================
# TEST FIXTURE MAPPING
# =============================================================================
# Maps test fixtures to the rules they verify.

fixtures:
  free_functions:
    tests: [E-FN-FREE, V-PUB, Q-ITEM, R-CONTAINS-ITEM, R-CALLS-FUNCTION]

  methods:
    tests: [E-FN-ASSOC, E-METHOD-SELF, E-IMPL-INHERENT, V-IMPL-BLOCK, Q-IMPL-INHERENT, Q-INHERENT-METHOD]

  trait_def:
    tests: [E-TRAIT, E-METHOD-TRAIT-DEF, V-TRAIT-METHOD-DEF, Q-TRAIT-METHOD-DEF, R-CONTAINS-TRAIT-MEMBER, M-TRAIT-NO-CONST-FN]

  trait_impl:
    tests: [E-IMPL-TRAIT, E-METHOD-TRAIT-IMPL, V-IMPL-BLOCK, V-TRAIT-IMPL-METHOD, Q-IMPL-TRAIT, Q-TRAIT-IMPL-METHOD, R-IMPLEMENTS]

  supertraits:
    tests: [E-TRAIT, R-EXTENDS-INTERFACE, M-TRAIT-BOUNDS]

  associated_types:
    tests: [E-TYPE-ALIAS-ASSOC, V-TRAIT-IMPL-ASSOC-TYPE, Q-ASSOC-TYPE, R-CONTAINS-ASSOC-TYPE]

  associated_constants:
    tests: [E-CONST-ASSOC, V-TRAIT-IMPL-CONST]

  visibility:
    tests: [V-PUB, V-PUB-CRATE, V-PUB-SELF, V-PRIVATE]

  basic_mod:
    tests: [E-MOD-CRATE, E-MOD-DECL, Q-CRATE-ROOT, Q-MODULE, R-CONTAINS-MODULE]

  structs:
    tests: [E-STRUCT, E-PROPERTY, V-PUB, V-PROPERTY, Q-ITEM, Q-PROPERTY, R-CONTAINS-PROPERTY, R-USES-TYPE, M-PROPERTY-TYPE]

  enums:
    tests: [E-ENUM, E-ENUM-VARIANT, V-ENUM-VARIANT, Q-ENUM-VARIANT, R-CONTAINS-ENUM-VARIANT, M-ENUM-VARIANT-VALUE]

  unions:
    tests: [E-UNION, E-PROPERTY, R-CONTAINS-PROPERTY]

  constants:
    tests: [E-CONST]

  statics:
    tests: [E-STATIC, M-STATIC-MUTABILITY]

  extern_blocks:
    tests: [E-EXTERN-BLOCK, E-EXTERN-FN, E-EXTERN-STATIC, R-CONTAINS-EXTERN-ITEM]

  type_aliases:
    tests: [E-TYPE-ALIAS, M-TYPE-ALIAS-TARGET]

  async_functions:
    tests: [M-FN-ASYNC]

  generic_structs:
    tests: [M-GENERIC, E-PROPERTY, R-CONTAINS-PROPERTY]

  tuple_and_unit_structs:
    tests: [E-STRUCT, E-PROPERTY, Q-PROPERTY, R-CONTAINS-PROPERTY, M-PROPERTY-TYPE]

  complex_enums:
    tests: [E-ENUM, E-ENUM-VARIANT, Q-ENUM-VARIANT, R-CONTAINS-ENUM-VARIANT, R-USES-TYPE]

  macro_rules:
    tests: [E-MACRO-RULES]
