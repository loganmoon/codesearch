# TypeScript Entity Extraction Specification
# ==========================================
#
# This specification defines the rules for extracting entities, relationships,
# and metadata from TypeScript source code. Rules are identified by unique IDs
# and can be referenced by test fixtures.
#
# Rule ID Format:
#   E-xxx  = Entity extraction rules
#   V-xxx  = Visibility rules
#   Q-xxx  = Qualified name rules
#   R-xxx  = Relationship rules
#   M-xxx  = Metadata rules
#
# Reference: https://www.typescriptlang.org/docs/handbook/
#
# Last validated against TypeScript Handbook: 2025-12-31

version: "1.0"
language: typescript

# =============================================================================
# ENTITY TYPES
# =============================================================================
# Defines which TypeScript constructs produce which entity types.

entity_rules:

  # ---------------------------------------------------------------------------
  # Modules (ES Modules)
  # Reference: https://www.typescriptlang.org/docs/handbook/2/modules.html
  # ---------------------------------------------------------------------------
  - id: E-MOD-FILE
    description: "A file with import/export statements produces a Module entity"
    construct: "file with `import` or `export` at top level"
    produces: Module
    note: |
      In TypeScript, any file containing a top-level `import` or `export` is
      considered a module. Files without these are scripts in the global scope.
      The module is identified by its file path relative to the project root.
    reference: "https://www.typescriptlang.org/docs/handbook/2/modules.html#how-javascript-modules-are-defined"
    tested_by: [basic_module, imports_exports]

  - id: E-MOD-NAMESPACE
    description: "A namespace declaration produces a Module entity"
    construct: "namespace Foo { ... }"
    produces: Module
    note: |
      Namespaces (formerly "internal modules") provide a way to organize code.
      The `namespace` keyword is preferred over the older `module` keyword for
      internal modules to avoid confusion with ES modules.
    divergence: |
      TypeScript has two distinct module systems: ES Modules (file-based) and
      Namespaces (declaration-based). We map both to the Module entity type for
      simplicity. In formal TypeScript semantics, they have different behaviors:
      - ES Modules: Runtime construct with file boundaries
      - Namespaces: Compile-time organization that can span files and merge
      This conflation may lose semantic distinction but enables unified searching.
    reference: "https://www.typescriptlang.org/docs/handbook/namespaces.html"
    tested_by: [namespaces, nested_namespaces]

  - id: E-MOD-NAMESPACE-MERGED
    description: "Multiple namespace declarations with same name merge into one Module"
    construct: "namespace Foo { ... } namespace Foo { ... }"
    produces: Module
    note: |
      TypeScript supports declaration merging for namespaces. Multiple namespace
      declarations with the same name contribute to a single merged namespace.
      Non-exported members remain private to their original declaration.
    reference: "https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-namespaces"
    tested_by: [namespace_merging]

  # ---------------------------------------------------------------------------
  # Classes
  # Reference: https://www.typescriptlang.org/docs/handbook/2/classes.html
  # ---------------------------------------------------------------------------
  - id: E-CLASS
    description: "A class declaration produces a Class entity"
    construct: "class Name { ... }"
    produces: Class
    tested_by: [classes, generic_classes]

  - id: E-CLASS-ABSTRACT
    description: "An abstract class declaration produces a Class entity"
    construct: "abstract class Name { ... }"
    produces: Class
    condition: "class has `abstract` modifier"
    note: |
      Abstract classes cannot be instantiated directly and serve as base classes.
      They may contain abstract methods that must be implemented by subclasses.
    reference: "https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-classes-and-members"
    tested_by: [abstract_classes]

  - id: E-CLASS-EXPR
    description: "A class expression assigned to a variable produces a Class entity"
    construct: "const Foo = class { ... }"
    produces: Class
    note: |
      Class expressions can be anonymous or named. When assigned to a variable,
      the entity name is derived from the variable name.
    tested_by: [class_expressions]

  # ---------------------------------------------------------------------------
  # Interfaces
  # Reference: https://www.typescriptlang.org/docs/handbook/2/objects.html
  # ---------------------------------------------------------------------------
  - id: E-INTERFACE
    description: "An interface declaration produces an Interface entity"
    construct: "interface Name { ... }"
    produces: Interface
    note: |
      Interfaces define the shape of objects. Unlike type aliases, interfaces
      can be extended and participate in declaration merging.
    reference: "https://www.typescriptlang.org/docs/handbook/2/objects.html"
    tested_by: [interfaces, interface_extends]

  - id: E-INTERFACE-MERGED
    description: "Multiple interface declarations with same name merge into one Interface"
    construct: "interface Foo { a: string } interface Foo { b: number }"
    produces: Interface
    note: |
      Interfaces with the same name automatically merge. Non-function members
      must be unique or have identical types. Function members become overloads.
    reference: "https://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-interfaces"
    tested_by: [interface_merging]

  # ---------------------------------------------------------------------------
  # Type Aliases
  # Reference: https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases
  # ---------------------------------------------------------------------------
  - id: E-TYPE-ALIAS
    description: "A type alias declaration produces a TypeAlias entity"
    construct: "type Name = ...;"
    produces: TypeAlias
    note: |
      Type aliases create a new name for any type. Unlike interfaces, type
      aliases cannot participate in declaration merging and can represent
      primitives, unions, tuples, and other complex types.
    reference: "https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases"
    tested_by: [type_aliases, generic_type_aliases]

  # ---------------------------------------------------------------------------
  # Enums
  # Reference: https://www.typescriptlang.org/docs/handbook/enums.html
  # ---------------------------------------------------------------------------
  - id: E-ENUM
    description: "An enum declaration produces an Enum entity"
    construct: "enum Name { ... }"
    produces: Enum
    note: |
      Enums allow defining a set of named constants. TypeScript provides both
      numeric and string-based enums. Enums are both a type and a value.
    reference: "https://www.typescriptlang.org/docs/handbook/enums.html"
    tested_by: [enums, const_enums]

  - id: E-ENUM-CONST
    description: "A const enum declaration produces an Enum entity"
    construct: "const enum Name { ... }"
    produces: Enum
    condition: "enum has `const` modifier"
    note: |
      Const enums are completely removed during compilation and inlined at
      use sites. They cannot have computed members.
    tested_by: [const_enums]

  - id: E-ENUM-MEMBER
    description: "An enum member produces an EnumVariant entity"
    construct: "enum E { Member, Member2 = 'value' }"
    produces: EnumVariant
    note: |
      Enum members can be numeric (auto-incrementing from 0) or string-valued.
      Numeric enum members get reverse mappings; string members do not.
    reference: "https://www.typescriptlang.org/docs/handbook/enums.html"
    tested_by: [enums, string_enums]

  # ---------------------------------------------------------------------------
  # Functions
  # Reference: https://www.typescriptlang.org/docs/handbook/2/functions.html
  # ---------------------------------------------------------------------------
  - id: E-FN-DECL
    description: "A function declaration produces a Function entity"
    construct: "function name() { ... }"
    produces: Function
    tested_by: [functions, async_functions, generator_functions]

  - id: E-FN-EXPR
    description: "A function expression assigned to a variable produces a Function entity"
    construct: "const foo = function() { ... }"
    produces: Function
    note: "Named function expressions use the function's name; anonymous ones use the variable name"
    tested_by: [function_expressions]

  - id: E-FN-ARROW
    description: "An arrow function assigned to a const/let produces a Function entity"
    construct: "const foo = () => { ... }"
    produces: Function
    note: |
      Arrow functions have lexical `this` binding and cannot be used as
      constructors. When assigned to a const/let at module level, they
      produce a Function entity.
    tested_by: [arrow_functions]

  - id: E-FN-GENERATOR
    description: "A generator function produces a Function entity"
    construct: "function* name() { ... }"
    produces: Function
    condition: "function has `*` generator modifier"
    tested_by: [generator_functions]

  # ---------------------------------------------------------------------------
  # Methods
  # Reference: https://www.typescriptlang.org/docs/handbook/2/classes.html#methods
  # ---------------------------------------------------------------------------
  - id: E-METHOD-CLASS
    description: "A class method produces a Method entity"
    construct: "class C { method() { ... } }"
    produces: Method
    tested_by: [methods, static_methods]

  - id: E-METHOD-STATIC
    description: "A static class method produces a Method entity"
    construct: "class C { static method() { ... } }"
    produces: Method
    condition: "method has `static` modifier"
    note: |
      Static methods are called on the class itself, not on instances.
      They cannot access `this` as an instance reference.
    reference: "https://www.typescriptlang.org/docs/handbook/2/classes.html#static-members"
    tested_by: [static_methods]

  - id: E-METHOD-ABSTRACT
    description: "An abstract method signature produces a Method entity"
    construct: "abstract class C { abstract method(): void; }"
    produces: Method
    condition: "method is in abstract class and has `abstract` modifier"
    note: "Abstract methods have no implementation and must be implemented by subclasses"
    reference: "https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-classes-and-members"
    tested_by: [abstract_classes]

  - id: E-METHOD-INTERFACE
    description: "An interface method signature produces a Method entity"
    construct: "interface I { method(): void; }"
    produces: Method
    note: "Interface methods are always signatures without implementation"
    tested_by: [interfaces]

  - id: E-PROPERTY-INTERFACE
    description: "An interface property signature produces a Property entity"
    construct: "interface I { prop: Type; }"
    produces: Property
    note: |
      Interface properties define the shape of object properties.
      They can be optional (?) or readonly.
    tested_by: [interfaces, interface_properties]

  - id: E-METHOD-GETTER
    description: "A getter accessor produces a Method entity"
    construct: "class C { get prop() { ... } }"
    produces: Method
    note: |
      Getters are accessor properties that allow computed property access.
      A getter without a setter creates a readonly property.
    reference: "https://www.typescriptlang.org/docs/handbook/2/classes.html#getters--setters"
    tested_by: [accessors]

  - id: E-METHOD-SETTER
    description: "A setter accessor produces a Method entity"
    construct: "class C { set prop(value) { ... } }"
    produces: Method
    note: "Setters allow intercepting property assignment"
    reference: "https://www.typescriptlang.org/docs/handbook/2/classes.html#getters--setters"
    tested_by: [accessors]

  # ---------------------------------------------------------------------------
  # Variables and Constants
  # ---------------------------------------------------------------------------
  - id: E-CONST
    description: "A const declaration at module level produces a Constant entity"
    construct: "const NAME = value;"
    produces: Constant
    condition: "const declaration at module/namespace scope (not in function body)"
    note: |
      Module-level constants are typically exported values or configuration.
      Only top-level const declarations become entities; block-scoped ones do not.
    tested_by: [constants, exported_constants]

  - id: E-VAR-LET
    description: "A let/var declaration at module level produces a Variable entity"
    construct: "let name = value;"
    produces: Variable
    condition: "let/var declaration at module/namespace scope (not in function body)"
    note: "Only module-level variable declarations become entities"
    tested_by: [variables]

  # ---------------------------------------------------------------------------
  # Properties (Class Fields)
  # Reference: https://www.typescriptlang.org/docs/handbook/2/classes.html#fields
  # ---------------------------------------------------------------------------
  - id: E-PROPERTY-FIELD
    description: "A class field declaration produces a Property entity"
    construct: "class C { field: Type; }"
    produces: Property
    note: |
      Class fields can have type annotations, initializers, and modifiers
      (public, private, protected, readonly, static).
    reference: "https://www.typescriptlang.org/docs/handbook/2/classes.html#fields"
    tested_by: [class_fields, private_fields]

  - id: E-PROPERTY-PARAM
    description: "A parameter property produces a Property entity"
    construct: "class C { constructor(public field: Type) {} }"
    produces: Property
    condition: "constructor parameter has visibility modifier (public, private, protected) or readonly"
    note: |
      Parameter properties are a TypeScript shorthand that declares and
      initializes a class field from a constructor parameter.
    reference: "https://www.typescriptlang.org/docs/handbook/2/classes.html#parameter-properties"
    tested_by: [parameter_properties]

  - id: E-PROPERTY-PRIVATE-FIELD
    description: "A private class field (#field) produces a Property entity"
    construct: "class C { #field: Type; }"
    produces: Property
    note: |
      ECMAScript private fields use the # prefix and provide hard runtime
      privacy, unlike TypeScript's `private` keyword which is compile-time only.
    reference: "https://www.typescriptlang.org/docs/handbook/2/classes.html#caveats"
    tested_by: [private_fields]

  - id: E-PROPERTY-ARROW-FIELD
    description: "An arrow function assigned to a class field produces a Property entity"
    construct: "class C { handler = () => { ... }; }"
    produces: Property
    note: |
      Arrow functions as class fields maintain lexical `this` binding.
      They are properties whose value is a function, not methods.
    tested_by: [arrow_field_properties]

  # ---------------------------------------------------------------------------
  # Ambient Declarations
  # Reference: https://www.typescriptlang.org/docs/handbook/2/type-declarations.html
  # ---------------------------------------------------------------------------
  - id: E-AMBIENT-VAR
    description: "A declare var/let/const produces an ambient Variable/Constant entity"
    construct: "declare const NAME: Type;"
    produces: [Constant, Variable]
    condition: "declaration has `declare` keyword"
    note: |
      Ambient declarations describe the shape of existing JavaScript code.
      They have no runtime representation and are used in .d.ts files.
    reference: "https://www.typescriptlang.org/docs/handbook/2/type-declarations.html"
    tested_by: [ambient_declarations]

  - id: E-AMBIENT-FUNCTION
    description: "A declare function produces an ambient Function entity"
    construct: "declare function name(): Type;"
    produces: Function
    condition: "function declaration has `declare` keyword"
    note: "Ambient functions have no implementation body"
    tested_by: [ambient_declarations]

  - id: E-AMBIENT-CLASS
    description: "A declare class produces an ambient Class entity"
    construct: "declare class Name { ... }"
    produces: Class
    condition: "class declaration has `declare` keyword"
    note: "Ambient classes describe the shape of existing JavaScript classes"
    tested_by: [ambient_declarations]

  - id: E-AMBIENT-NAMESPACE
    description: "A declare namespace produces an ambient Module entity"
    construct: "declare namespace Name { ... }"
    produces: Module
    condition: "namespace declaration has `declare` keyword"
    note: "Ambient namespaces describe global namespace augmentations"
    tested_by: [ambient_declarations]

  - id: E-GLOBAL-AUGMENTATION
    description: "A declare global block augments the global scope"
    construct: "declare global { ... }"
    produces: Module
    note: |
      Global augmentations add declarations to the global scope from within
      a module. Must be inside a module (file with import/export).
    reference: "https://www.typescriptlang.org/docs/handbook/declaration-merging.html#global-augmentation"
    tested_by: [global_augmentation]

  # ---------------------------------------------------------------------------
  # Signatures (Interface/Type Members)
  # Reference: https://www.typescriptlang.org/docs/handbook/2/functions.html
  # ---------------------------------------------------------------------------
  - id: E-INDEX-SIGNATURE
    description: "An index signature produces a Property entity"
    construct: "interface I { [key: string]: Type; }"
    produces: Property
    note: |
      Index signatures define the type of properties accessed with bracket
      notation. The key type must be string, number, or symbol.
    reference: "https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures"
    tested_by: [index_signatures]

  - id: E-CALL-SIGNATURE
    description: "A call signature produces a Method entity"
    construct: "interface I { (arg: Type): ReturnType; }"
    produces: Method
    note: |
      Call signatures describe how a type can be called as a function.
      Types with call signatures are callable.
    reference: "https://www.typescriptlang.org/docs/handbook/2/functions.html#call-signatures"
    tested_by: [call_signatures]

  - id: E-CONSTRUCT-SIGNATURE
    description: "A construct signature produces a Method entity"
    construct: "interface I { new (arg: Type): Instance; }"
    produces: Method
    note: |
      Construct signatures describe how a type can be instantiated with `new`.
      Used for describing constructor functions and classes.
    reference: "https://www.typescriptlang.org/docs/handbook/2/functions.html#construct-signatures"
    tested_by: [construct_signatures]

  # ---------------------------------------------------------------------------
  # JSX Elements (React/Preact)
  # Reference: https://www.typescriptlang.org/docs/handbook/jsx.html
  # ---------------------------------------------------------------------------
  - id: E-JSX-COMPONENT
    description: "A function component returning JSX produces a Function entity"
    construct: "function Component(): JSX.Element { return <div/>; }"
    produces: Function
    condition: "function returns JSX element and follows component naming (PascalCase)"
    note: |
      JSX components are functions that return JSX elements.
      By convention, component names start with uppercase letters.
    reference: "https://www.typescriptlang.org/docs/handbook/jsx.html"
    tested_by: [jsx_components]

  - id: E-JSX-ARROW-COMPONENT
    description: "An arrow function component produces a Function entity"
    construct: "const Component = (): JSX.Element => <div/>;"
    produces: Function
    condition: "arrow function assigned to PascalCase name returning JSX"
    tested_by: [jsx_components]


# =============================================================================
# VISIBILITY RULES
# =============================================================================
# Defines how visibility is determined for entities.
# Rules are evaluated in precedence order; first matching rule wins.
#
# TypeScript has TWO visibility systems:
# 1. Module-level: export vs no export (applies to ES module members)
# 2. Class-level: public/private/protected (applies to class members)
#
# For code search, we map these to our standard visibility model:
# - Public: Accessible from anywhere (exported module members, public class members)
# - Private: Accessible only within defining scope (non-exported, private class members)
# - Protected: Accessible to subclasses (protected class members)
# - Internal: Not used in TypeScript (TypeScript has no crate-level visibility)

visibility_rules:

  # ---------------------------------------------------------------------------
  # Special cases (visibility determined by context)
  # ---------------------------------------------------------------------------
  - id: V-INTERFACE-MEMBER
    description: "Interface members have no visibility (None)"
    applies_to: [Method, Property]
    condition: "member is defined inside an interface"
    result: null  # None
    reason: |
      Interface members define a contract and don't have visibility modifiers.
      The visibility of interface members is determined by the interface itself.
    reference: "https://www.typescriptlang.org/docs/handbook/2/objects.html"
    precedence: 1
    tested_by: [interfaces]

  - id: V-TYPE-ALIAS
    description: "Type aliases have no visibility modifier (treated as module export)"
    applies_to: TypeAlias
    condition: "type alias visibility follows module export rules"
    result: null  # Visibility determined by export keyword at module level
    reason: "Type aliases themselves don't have visibility modifiers; they use export"
    precedence: 1
    tested_by: [type_aliases]

  # ---------------------------------------------------------------------------
  # Class member visibility
  # Reference: https://www.typescriptlang.org/docs/handbook/2/classes.html#member-visibility
  # ---------------------------------------------------------------------------
  - id: V-CLASS-PUBLIC
    description: "Public class members (explicit or default) have Public visibility"
    applies_to: [Method, Property]
    condition: "has `public` modifier OR no visibility modifier on class member"
    result: Public
    note: |
      In TypeScript classes, members without a visibility modifier are public
      by default. The `public` modifier can be explicitly added for clarity.
    reference: "https://www.typescriptlang.org/docs/handbook/2/classes.html#public"
    precedence: 10
    tested_by: [classes, methods]

  - id: V-CLASS-PRIVATE
    description: "Private class members have Private visibility"
    applies_to: [Method, Property]
    condition: "has `private` modifier"
    result: Private
    note: |
      TypeScript's `private` is compile-time only and can be accessed at
      runtime via bracket notation. Use # for hard runtime privacy.
    reference: "https://www.typescriptlang.org/docs/handbook/2/classes.html#private"
    precedence: 10
    tested_by: [private_members]

  - id: V-CLASS-PROTECTED
    description: "Protected class members have Protected visibility"
    applies_to: [Method, Property]
    condition: "has `protected` modifier"
    result: Protected
    note: |
      Protected members are visible to the defining class and its subclasses.
      A derived class can expose a protected member as public.
    reference: "https://www.typescriptlang.org/docs/handbook/2/classes.html#protected"
    precedence: 10
    tested_by: [protected_members]

  - id: V-CLASS-PRIVATE-FIELD
    description: "ECMAScript private fields (#) have Private visibility"
    applies_to: Property
    condition: "field name starts with #"
    result: Private
    note: "ECMAScript private fields provide hard runtime privacy"
    reference: "https://www.typescriptlang.org/docs/handbook/2/classes.html#caveats"
    precedence: 5
    tested_by: [private_fields]

  # ---------------------------------------------------------------------------
  # Module-level visibility (export)
  # ---------------------------------------------------------------------------
  - id: V-EXPORT
    description: "Exported module members have Public visibility"
    applies_to: [Function, Class, Interface, TypeAlias, Enum, Constant, Variable, Module]
    condition: "has `export` keyword"
    result: Public
    note: |
      The export keyword makes a declaration available for import by other
      modules. This is the primary visibility mechanism for ES modules.
    reference: "https://www.typescriptlang.org/docs/handbook/2/modules.html"
    precedence: 20
    tested_by: [exports, reexports]

  - id: V-EXPORT-DEFAULT
    description: "Default exported members have Public visibility"
    applies_to: [Function, Class, Interface, TypeAlias, Constant, Variable]
    condition: "has `export default`"
    result: Public
    note: "Default exports are a special case of exports, one per module"
    reference: "https://www.typescriptlang.org/docs/handbook/2/modules.html#default-exports"
    precedence: 20
    tested_by: [default_exports]

  - id: V-NAMESPACE-EXPORT
    description: "Exported namespace members have Public visibility"
    applies_to: "*"
    condition: "member inside namespace has `export` keyword"
    result: Public
    note: |
      Within namespaces, members must be explicitly exported to be visible
      outside the namespace. Non-exported members are private to that namespace.
    reference: "https://www.typescriptlang.org/docs/handbook/namespaces.html#namespacing"
    precedence: 20
    tested_by: [namespaces]

  # ---------------------------------------------------------------------------
  # Default visibility (no modifier)
  # ---------------------------------------------------------------------------
  - id: V-MODULE-PRIVATE
    description: "Non-exported module members have Private visibility"
    applies_to: [Function, Class, Interface, TypeAlias, Enum, Constant, Variable]
    condition: "no `export` keyword on module-level declaration"
    result: Private
    note: |
      Module-level declarations without export are private to the module.
      They cannot be imported by other modules.
    reference: "https://www.typescriptlang.org/docs/handbook/2/modules.html"
    precedence: 100  # lowest precedence (default)
    tested_by: [modules, visibility]


# =============================================================================
# QUALIFIED NAME RULES
# =============================================================================
# Defines how qualified names are constructed for entities.
#
# TypeScript qualified names follow these patterns:
# - ES Modules: File path based (module path + entity name)
# - Namespaces: Dot-separated (Namespace.SubNamespace.Entity)
# - Classes: ClassName.memberName

qualified_name_rules:

  # ---------------------------------------------------------------------------
  # Module-level qualified names
  # ---------------------------------------------------------------------------
  - id: Q-MODULE-FILE
    description: "ES module is named after its file path"
    pattern: "{relative_path_without_extension}"
    examples:
      - "src/utils/helpers"  # from src/utils/helpers.ts
      - "components/Button"  # from components/Button.tsx
    note: |
      ES module names are derived from their file paths relative to the
      project root, without the file extension.
    tested_by: [basic_module]

  - id: Q-MODULE-NAMESPACE
    description: "Namespace is named by its declaration"
    pattern: "{parent_namespace}.{name}"
    examples:
      - "Validation"  # top-level namespace
      - "Shapes.Polygons"  # nested namespace
    note: "Namespaces use dot notation for nesting"
    tested_by: [namespaces, nested_namespaces]

  - id: Q-ITEM-MODULE
    description: "Module-level items are qualified under their module"
    pattern: "{module}.{name}"
    applies_to: [Function, Class, Interface, TypeAlias, Enum, Constant, Variable]
    examples:
      - "src/utils/helpers.formatDate"  # function in module
      - "src/models/User.User"  # class in module
    note: "Items at module level are qualified with the module path"
    tested_by: [functions, classes, interfaces]

  - id: Q-ITEM-NAMESPACE
    description: "Namespace-level items are qualified under their namespace"
    pattern: "{namespace}.{name}"
    applies_to: [Function, Class, Interface, TypeAlias, Enum, Constant, Variable]
    examples:
      - "Validation.StringValidator"  # interface in namespace
      - "Shapes.Polygons.Triangle"  # class in nested namespace
    note: "Items in namespaces use dot-separated paths"
    tested_by: [namespaces]

  # ---------------------------------------------------------------------------
  # Class member qualified names
  # ---------------------------------------------------------------------------
  - id: Q-METHOD-INSTANCE
    description: "Instance methods use dot notation from class"
    pattern: "{class_fqn}.{name}"
    examples:
      - "src/models/User.User.getName"  # instance method
      - "Validation.ZipCodeValidator.isAcceptable"  # method in namespace class
    note: "Instance methods are qualified as Class.methodName"
    tested_by: [methods]

  - id: Q-METHOD-STATIC
    description: "Static methods include 'static' qualifier"
    pattern: "{class_fqn}.static.{name}"
    examples:
      - "src/models/User.User.static.create"  # static method
    note: "Static methods are distinguished from instance methods"
    divergence: |
      TypeScript doesn't have a canonical path format for static vs instance.
      We use .static. to distinguish for searchability.
    tested_by: [static_methods]

  - id: Q-PROPERTY-INSTANCE
    description: "Instance properties use dot notation from class"
    pattern: "{class_fqn}.{name}"
    examples:
      - "src/models/User.User.email"  # instance property
    tested_by: [class_fields]

  - id: Q-PROPERTY-STATIC
    description: "Static properties include 'static' qualifier"
    pattern: "{class_fqn}.static.{name}"
    examples:
      - "src/models/User.User.static.DEFAULT_ROLE"
    tested_by: [static_properties]

  # ---------------------------------------------------------------------------
  # Interface member qualified names
  # ---------------------------------------------------------------------------
  - id: Q-INTERFACE-METHOD
    description: "Interface methods are qualified under the interface"
    pattern: "{interface_fqn}.{name}"
    examples:
      - "src/types.Comparable.compareTo"
      - "Validation.StringValidator.isAcceptable"
    tested_by: [interfaces]

  - id: Q-INTERFACE-PROPERTY
    description: "Interface properties are qualified under the interface"
    pattern: "{interface_fqn}.{name}"
    examples:
      - "src/types.User.id"
      - "src/types.User.name"
    tested_by: [interfaces]


# =============================================================================
# RELATIONSHIP RULES
# =============================================================================
# Defines what relationships are created between entities.

relationship_rules:

  # ---------------------------------------------------------------------------
  # Containment (structural hierarchy)
  # ---------------------------------------------------------------------------
  - id: R-CONTAINS-MODULE-ITEM
    description: "Module CONTAINS its top-level declarations"
    kind: Contains
    from: Module
    to: [Function, Class, Interface, TypeAlias, Enum, Constant, Variable, Module]
    tested_by: [basic_module, namespaces]

  - id: R-CONTAINS-CLASS-MEMBER
    description: "Class CONTAINS its methods and properties"
    kind: Contains
    from: Class
    to: [Method, Property]
    tested_by: [classes, methods, class_fields]

  - id: R-CONTAINS-INTERFACE-MEMBER
    description: "Interface CONTAINS its method and property signatures"
    kind: Contains
    from: Interface
    to: [Method, Property]
    tested_by: [interfaces]

  - id: R-CONTAINS-ENUM-MEMBER
    description: "Enum CONTAINS its variants"
    kind: Contains
    from: Enum
    to: EnumVariant
    note: "Enum members are contained by their parent enum"
    tested_by: [enums]

  - id: R-CONTAINS-NAMESPACE-ITEM
    description: "Namespace CONTAINS its exported members"
    kind: Contains
    from: Module
    to: [Function, Class, Interface, TypeAlias, Enum, Constant, Variable, Module]
    condition: "namespace contains exported members"
    tested_by: [namespaces]

  # ---------------------------------------------------------------------------
  # Inheritance and Implementation
  # ---------------------------------------------------------------------------
  - id: R-INHERITS-FROM
    description: "Class INHERITS_FROM its base class"
    kind: InheritsFrom
    from: Class
    to: Class
    condition: "class uses `extends` clause"
    note: |
      TypeScript supports single inheritance for classes. A class can only
      extend one other class, but can implement multiple interfaces.
    reference: "https://www.typescriptlang.org/docs/handbook/2/classes.html#extends-clauses"
    tested_by: [class_inheritance]

  - id: R-IMPLEMENTS
    description: "Class IMPLEMENTS an interface"
    kind: Implements
    from: Class
    to: Interface
    condition: "class uses `implements` clause"
    note: |
      A class can implement multiple interfaces. The implements clause is a
      check that the class satisfies the interface, but doesn't change the
      class's type.
    reference: "https://www.typescriptlang.org/docs/handbook/2/classes.html#implements-clauses"
    tested_by: [class_implements]

  - id: R-EXTENDS-INTERFACE
    description: "Interface EXTENDS_INTERFACE another interface"
    kind: ExtendsInterface
    from: Interface
    to: Interface
    condition: "interface uses `extends` clause"
    note: |
      Interfaces can extend multiple other interfaces, combining their
      members into a single interface.
    reference: "https://www.typescriptlang.org/docs/handbook/2/objects.html#extending-types"
    tested_by: [interface_extends]

  # ---------------------------------------------------------------------------
  # Import relationships
  # ---------------------------------------------------------------------------
  - id: R-IMPORTS-NAMED
    description: "Module IMPORTS specific named exports"
    kind: Imports
    from: Module
    to: [Function, Class, Interface, TypeAlias, Enum, Constant, Variable]
    condition: "import { name } from 'module'"
    tested_by: [imports]

  - id: R-IMPORTS-DEFAULT
    description: "Module IMPORTS default export"
    kind: Imports
    from: Module
    to: [Function, Class, Interface, TypeAlias, Constant]
    condition: "import name from 'module'"
    tested_by: [default_exports]

  - id: R-IMPORTS-NAMESPACE
    description: "Module IMPORTS entire module as namespace"
    kind: Imports
    from: Module
    to: Module
    condition: "import * as name from 'module'"
    tested_by: [namespace_imports]

  - id: R-IMPORTS-TYPE
    description: "Module IMPORTS type-only import"
    kind: Imports
    from: Module
    to: [Interface, TypeAlias, Class]
    condition: "import type { name } from 'module'"
    note: |
      Type-only imports are erased at compile time and don't create
      runtime dependencies.
    reference: "https://www.typescriptlang.org/docs/handbook/2/modules.html#typescript-specific-es-module-syntax"
    tested_by: [type_imports]

  # ---------------------------------------------------------------------------
  # Re-export relationships
  # Reference: https://www.typescriptlang.org/docs/handbook/2/modules.html#re-exports
  # ---------------------------------------------------------------------------
  - id: R-REEXPORTS-NAMED
    description: "Module REEXPORTS named exports from another module"
    kind: Reexports
    from: Module
    to: [Function, Class, Interface, TypeAlias, Enum, Constant, Variable]
    condition: "export { name } from 'module'"
    note: "Re-exports make items from one module available from another"
    reference: "https://www.typescriptlang.org/docs/handbook/2/modules.html#re-exports"
    tested_by: [reexports]

  - id: R-REEXPORTS-ALL
    description: "Module REEXPORTS all exports from another module"
    kind: Reexports
    from: Module
    to: Module
    condition: "export * from 'module'"
    note: |
      Barrel exports re-export all named exports from another module.
      Does not include default exports.
    tested_by: [barrel_exports]

  - id: R-REEXPORTS-NAMESPACE
    description: "Module REEXPORTS another module as a namespace"
    kind: Reexports
    from: Module
    to: Module
    condition: "export * as name from 'module'"
    note: "Creates a namespace object containing all exports from the source module"
    reference: "https://www.typescriptlang.org/docs/handbook/2/modules.html#re-exports"
    tested_by: [namespace_reexports]

  - id: R-REEXPORTS-DEFAULT
    description: "Module REEXPORTS default export"
    kind: Reexports
    from: Module
    to: [Function, Class, Interface, TypeAlias, Constant]
    condition: "export { default } from 'module' or export { default as name } from 'module'"
    tested_by: [reexports]

  # ---------------------------------------------------------------------------
  # Call relationships
  # ---------------------------------------------------------------------------
  - id: R-CALLS-FUNCTION
    description: "Function/Method CALLS another function/method"
    kind: Calls
    from: [Function, Method]
    to: [Function, Method]
    condition: "function call expression in body"
    tested_by: [function_calls, method_calls]

  # ---------------------------------------------------------------------------
  # Type usage relationships
  # ---------------------------------------------------------------------------
  - id: R-USES-TYPE
    description: "Entity USES a type it references"
    kind: Uses
    from: [Function, Method, Class, Interface, TypeAlias, Property, Constant, Variable]
    to: [Class, Interface, TypeAlias, Enum]
    condition: "type appears in signature, field, or type expression"
    tested_by: [type_usage, generic_constraints]


# =============================================================================
# METADATA RULES
# =============================================================================
# Defines what metadata is captured for entities.

metadata_rules:

  # ---------------------------------------------------------------------------
  # Function/Method metadata
  # ---------------------------------------------------------------------------
  - id: M-FN-ASYNC
    description: "Async functions have is_async=true"
    applies_to: [Function, Method]
    field: is_async
    condition: "function has `async` keyword"
    tested_by: [async_functions]

  - id: M-FN-GENERATOR
    description: "Generator functions have is_generator=true"
    applies_to: [Function, Method]
    field: is_generator
    condition: "function has `*` modifier"
    tested_by: [generator_functions]

  - id: M-FN-ARROW
    description: "Arrow functions have is_arrow=true"
    applies_to: Function
    field: is_arrow
    condition: "function uses arrow syntax"
    tested_by: [arrow_functions]

  - id: M-FN-OVERLOADED
    description: "Overloaded functions have overload_count and is_overloaded=true"
    applies_to: [Function, Method]
    fields: [is_overloaded, overload_count]
    condition: "function has multiple signature declarations"
    note: |
      TypeScript allows multiple function signatures followed by a single
      implementation. Each overload signature defines different parameter
      and return types.
    reference: "https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads"
    tested_by: [overloaded_functions]

  # ---------------------------------------------------------------------------
  # Class metadata
  # ---------------------------------------------------------------------------
  - id: M-CLASS-ABSTRACT
    description: "Abstract classes have is_abstract=true"
    applies_to: Class
    field: is_abstract
    condition: "class has `abstract` keyword"
    tested_by: [abstract_classes]

  # ---------------------------------------------------------------------------
  # Method metadata
  # ---------------------------------------------------------------------------
  - id: M-METHOD-STATIC
    description: "Static methods have is_static=true"
    applies_to: Method
    field: is_static
    condition: "method has `static` keyword"
    tested_by: [static_methods]

  - id: M-METHOD-ACCESSOR-GET
    description: "Getter methods have is_getter=true"
    applies_to: Method
    field: is_getter
    condition: "method has `get` keyword"
    tested_by: [accessors]

  - id: M-METHOD-ACCESSOR-SET
    description: "Setter methods have is_setter=true"
    applies_to: Method
    field: is_setter
    condition: "method has `set` keyword"
    tested_by: [accessors]

  - id: M-METHOD-ABSTRACT
    description: "Abstract methods have is_abstract=true"
    applies_to: Method
    field: is_abstract
    condition: "method has `abstract` keyword"
    tested_by: [abstract_classes]

  # ---------------------------------------------------------------------------
  # Property metadata
  # ---------------------------------------------------------------------------
  - id: M-PROPERTY-STATIC
    description: "Static properties have is_static=true"
    applies_to: Property
    field: is_static
    condition: "property has `static` keyword"
    tested_by: [static_properties]

  - id: M-PROPERTY-READONLY
    description: "Readonly properties have is_readonly=true"
    applies_to: Property
    field: is_readonly
    condition: "property has `readonly` keyword"
    tested_by: [readonly_properties]

  - id: M-PROPERTY-OPTIONAL
    description: "Optional properties have is_optional=true"
    applies_to: Property
    field: is_optional
    condition: "property has `?` modifier"
    tested_by: [optional_properties]

  # ---------------------------------------------------------------------------
  # Enum metadata
  # ---------------------------------------------------------------------------
  - id: M-ENUM-CONST
    description: "Const enums have is_const=true"
    applies_to: Enum
    field: is_const
    condition: "enum has `const` keyword"
    tested_by: [const_enums]

  - id: M-ENUM-STRING
    description: "String enums have enum_type='string'"
    applies_to: Enum
    field: enum_type
    condition: "all enum members have string literal initializers"
    note: |
      String enums require explicit string values for all members.
      They don't have reverse mappings like numeric enums.
    reference: "https://www.typescriptlang.org/docs/handbook/enums.html#string-enums"
    tested_by: [string_enums]

  - id: M-ENUM-NUMERIC
    description: "Numeric enums have enum_type='numeric'"
    applies_to: Enum
    field: enum_type
    condition: "enum members have numeric values (explicit or auto-incremented)"
    note: "Numeric enums auto-increment from 0 and have reverse mappings"
    tested_by: [enums]

  - id: M-ENUM-HETEROGENEOUS
    description: "Mixed enums have enum_type='heterogeneous'"
    applies_to: Enum
    field: enum_type
    condition: "enum has both string and numeric members"
    note: |
      Heterogeneous enums mix string and numeric members.
      Generally not recommended due to confusing semantics.
    tested_by: [heterogeneous_enums]

  # ---------------------------------------------------------------------------
  # Generic metadata
  # ---------------------------------------------------------------------------
  - id: M-GENERIC
    description: "Generic items have is_generic=true and generic_params list"
    applies_to: [Function, Method, Class, Interface, TypeAlias]
    fields: [is_generic, generic_params]
    condition: "item has type parameters"
    tested_by: [generic_classes, generic_functions, generic_interfaces]

  - id: M-GENERIC-CONSTRAINT
    description: "Type parameters may have constraints"
    applies_to: [Function, Method, Class, Interface, TypeAlias]
    field: generic_params
    condition: "type parameter has `extends` constraint"
    note: "Constraints limit what types can be used as type arguments"
    reference: "https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints"
    tested_by: [generic_constraints]

  - id: M-GENERIC-DEFAULT
    description: "Type parameters may have default values"
    applies_to: [Function, Method, Class, Interface, TypeAlias]
    field: generic_params
    condition: "type parameter has `= DefaultType` syntax"
    reference: "https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-parameter-defaults"
    tested_by: [generic_defaults]

  # ---------------------------------------------------------------------------
  # Class field metadata
  # ---------------------------------------------------------------------------
  - id: M-FIELD-INITIALIZER
    description: "Fields with initializers track their initial value"
    applies_to: Property
    field: has_initializer
    condition: "field has `= value` initializer"
    tested_by: [class_fields]

  # ---------------------------------------------------------------------------
  # Decorator metadata
  # ---------------------------------------------------------------------------
  - id: M-DECORATOR
    description: "Decorated items track their decorators"
    applies_to: [Class, Method, Property]
    field: decorators
    condition: "item has `@decorator` syntax"
    note: |
      TypeScript supports two decorator systems:
      1. Stage 3 decorators (TypeScript 5.0+): Standard ECMAScript decorators.
         Parameter decorators are NOT supported in Stage 3.
      2. Experimental decorators: Legacy system requiring `experimentalDecorators`.
         Supports parameter decorators but uses different semantics.
      Both use `@decorator` syntax but have different runtime behavior.
    reference: "https://www.typescriptlang.org/docs/handbook/decorators.html"
    tested_by: [decorators]

  - id: M-DECORATOR-PARAM
    description: "Parameter decorators tracked separately (experimental only)"
    applies_to: [Function, Method]
    field: parameter_decorators
    condition: "parameter has `@decorator` syntax (requires experimentalDecorators)"
    note: |
      Parameter decorators are only available with experimentalDecorators.
      Stage 3 decorators do NOT support parameter decorators.
    tested_by: [experimental_decorators]


# =============================================================================
# EXTRACTION HINTS
# =============================================================================
# These hints drive code generation for entity handlers. They extend the
# declarative rules above with implementation details needed for extraction.
#
# TypeScript extends JavaScript with:
# - Interfaces, type aliases, enums
# - Namespace modules (internal modules)
# - Abstract classes and methods
# - Ambient declarations (declare)
# - Parameter properties in constructors
# - Call/construct/index signatures

extraction_hints:

  # ---------------------------------------------------------------------------
  # Tree-sitter Queries
  # ---------------------------------------------------------------------------
  #
  # TypeScript inherits JavaScript's query precedence approach: overlapping
  # patterns are disambiguated via tree-sitter predicates (#not-match?, etc.)
  # directly in the queries rather than a separate mechanism.
  #
  # See javascript.yaml for precedence group documentation.
  #
  # TypeScript-specific query definitions. Note that TypeScript uses
  # `type_identifier` for type names instead of `identifier`.

  queries:

    # Inherits all JavaScript queries plus the following TypeScript-specific ones:

    # --- Class queries (TypeScript version uses type_identifier) ---

    TS_CLASS_DECLARATION:
      description: "TypeScript class declarations (including abstract)"
      capture: "class"
      query: |
        [
          (class_declaration
            name: (type_identifier) @name
            (class_heritage)? @heritage
            body: (class_body) @body) @class

          (abstract_class_declaration
            name: (type_identifier) @name
            (class_heritage)? @heritage
            body: (class_body) @body) @class

          (export_statement
            declaration: (class_declaration
              name: (type_identifier) @name
              (class_heritage)? @heritage
              body: (class_body) @body)) @class

          (export_statement
            declaration: (abstract_class_declaration
              name: (type_identifier) @name
              (class_heritage)? @heritage
              body: (class_body) @body)) @class
        ]

    TS_CLASS_EXPRESSION:
      description: "TypeScript class expressions"
      capture: "class"
      query: |
        [
          (lexical_declaration
            (variable_declarator
              name: (identifier) @name
              value: (class
                name: (type_identifier)? @class_name
                (class_heritage)? @heritage
                body: (class_body) @body))) @class

          (variable_declaration
            (variable_declarator
              name: (identifier) @name
              value: (class
                name: (type_identifier)? @class_name
                (class_heritage)? @heritage
                body: (class_body) @body))) @class
        ]

    TS_PROPERTY:
      description: "TypeScript class fields (uses public_field_definition)"
      capture: "property"
      query: |
        (class_body
          (public_field_definition
            name: [
              (property_identifier) @name
              (private_property_identifier) @name
            ]
            value: (_)? @value) @property)

    # --- Interface queries ---

    INTERFACE:
      description: "Interface declarations"
      capture: "interface"
      query: |
        [
          (interface_declaration
            name: (type_identifier) @name
            (extends_type_clause)? @extends_clause
            body: (interface_body) @body) @interface

          (export_statement
            declaration: (interface_declaration
              name: (type_identifier) @name
              (extends_type_clause)? @extends_clause
              body: (interface_body) @body)) @interface
        ]

    INTERFACE_PROPERTY:
      description: "Interface property signatures"
      capture: "interface_property"
      query: |
        (interface_body
          (property_signature
            name: (property_identifier) @name) @interface_property)

    INTERFACE_METHOD:
      description: "Interface method signatures"
      capture: "interface_method"
      query: |
        (interface_body
          (method_signature
            name: (property_identifier) @name) @interface_method)

    CALL_SIGNATURE:
      description: "Call signatures in interfaces"
      capture: "call_signature"
      query: |
        (interface_body
          (call_signature) @call_signature)

    CONSTRUCT_SIGNATURE:
      description: "Construct signatures in interfaces"
      capture: "construct_signature"
      query: |
        (interface_body
          (construct_signature) @construct_signature)

    INDEX_SIGNATURE:
      description: "Index signatures in interfaces"
      capture: "index_signature"
      query: |
        (interface_body
          (index_signature) @index_signature)

    # --- Type alias queries ---

    TYPE_ALIAS:
      description: "Type alias declarations"
      capture: "type_alias"
      query: |
        [
          (type_alias_declaration
            name: (type_identifier) @name
            type_parameters: (type_parameters)? @type_params
            value: (_) @value) @type_alias

          (export_statement
            declaration: (type_alias_declaration
              name: (type_identifier) @name
              type_parameters: (type_parameters)? @type_params
              value: (_) @value)) @type_alias
        ]

    # --- Enum queries ---

    ENUM:
      description: "Enum declarations (including const enum)"
      capture: "enum"
      query: |
        [
          (enum_declaration
            name: (identifier) @name
            body: (enum_body) @body) @enum

          (export_statement
            declaration: (enum_declaration
              name: (identifier) @name
              body: (enum_body) @body)) @enum
        ]

    ENUM_MEMBER:
      description: "Enum member variants"
      capture: "enum_member"
      query: |
        [
          (enum_body
            (property_identifier) @name) @enum_member

          (enum_body
            (enum_assignment
              name: (property_identifier) @name)) @enum_member
        ]

    # --- Namespace queries ---

    NAMESPACE:
      description: "Namespace/module declarations"
      capture: "namespace"
      query: |
        [
          (internal_module
            name: (identifier) @name
            body: (statement_block) @body) @namespace

          (internal_module
            name: (nested_identifier) @name
            body: (statement_block) @body) @namespace

          (export_statement
            declaration: (internal_module
              name: (identifier) @name
              body: (statement_block) @body)) @namespace

          (export_statement
            declaration: (internal_module
              name: (nested_identifier) @name
              body: (statement_block) @body)) @namespace
        ]

    # --- Abstract method queries ---

    ABSTRACT_METHOD:
      description: "Abstract method signatures in abstract classes"
      capture: "method"
      query: |
        (class_body
          (abstract_method_signature
            name: (property_identifier) @name) @method)

    # --- Ambient declaration queries ---

    AMBIENT_FUNCTION:
      description: "Ambient function declarations (declare function)"
      capture: "function"
      query: |
        (ambient_declaration
          (function_signature
            name: (identifier) @name) @function)

    AMBIENT_CONST:
      description: "Ambient const declarations (declare const)"
      capture: "const"
      query: |
        (ambient_declaration
          (lexical_declaration
            kind: "const"
            (variable_declarator
              name: (identifier) @name)) @const)

    AMBIENT_LET:
      description: "Ambient let declarations (declare let)"
      capture: "let"
      query: |
        (ambient_declaration
          (lexical_declaration
            kind: "let"
            (variable_declarator
              name: (identifier) @name)) @let)

    AMBIENT_VAR:
      description: "Ambient var declarations (declare var)"
      capture: "var"
      query: |
        (ambient_declaration
          (variable_declaration
            (variable_declarator
              name: (identifier) @name)) @var)

    AMBIENT_CLASS:
      description: "Ambient class declarations (declare class)"
      capture: "class"
      query: |
        [
          (ambient_declaration
            (class_declaration
              name: (type_identifier) @name
              body: (class_body) @body) @class)

          (ambient_declaration
            (abstract_class_declaration
              name: (type_identifier) @name
              body: (class_body) @body) @class)
        ]

    # --- Parameter property queries ---

    PARAMETER_PROPERTY:
      description: "Constructor parameter properties"
      capture: "property"
      query: |
        [
          (class_body
            (method_definition
              parameters: (formal_parameters
                (required_parameter
                  (accessibility_modifier)
                  pattern: (identifier) @name) @property)))

          (class_body
            (method_definition
              parameters: (formal_parameters
                (optional_parameter
                  (accessibility_modifier)
                  pattern: (identifier) @name) @property)))

          (class_body
            (method_definition
              parameters: (formal_parameters
                (required_parameter
                  "readonly"
                  pattern: (identifier) @name) @property)))

          (class_body
            (method_definition
              parameters: (formal_parameters
                (optional_parameter
                  "readonly"
                  pattern: (identifier) @name) @property)))
        ]

    # ---------------------------------------------------------------------------
    # JavaScript-compatible queries
    # ---------------------------------------------------------------------------
    # These queries handle standard JavaScript constructs that are also valid
    # TypeScript. TypeScript uses the same syntax for functions, variables,
    # and methods.

    FUNCTION_DECLARATION:
      description: "Standard function declarations"
      capture: "function"
      query: |
        [
          (function_declaration
            name: (identifier) @name
            parameters: (formal_parameters) @params
            body: (statement_block) @body) @function

          (generator_function_declaration
            name: (identifier) @name
            parameters: (formal_parameters) @params
            body: (statement_block) @body) @function

          (export_statement
            declaration: (function_declaration
              name: (identifier) @name
              parameters: (formal_parameters) @params
              body: (statement_block) @body)) @function

          (export_statement
            declaration: (generator_function_declaration
              name: (identifier) @name
              parameters: (formal_parameters) @params
              body: (statement_block) @body)) @function
        ]

    ARROW_FUNCTION:
      description: "Arrow functions assigned to variables"
      capture: "function"
      query: |
        (lexical_declaration
          (variable_declarator
            name: (identifier) @name
            value: (arrow_function
              parameters: [
                (formal_parameters) @params
                (identifier) @params
              ]?
              body: [
                (statement_block)
                (_)
              ] @body))) @function

        (variable_declaration
          (variable_declarator
            name: (identifier) @name
            value: (arrow_function
              parameters: [
                (formal_parameters) @params
                (identifier) @params
              ]?
              body: [
                (statement_block)
                (_)
              ] @body))) @function

        (export_statement
          declaration: (lexical_declaration
            (variable_declarator
              name: (identifier) @name
              value: (arrow_function
                parameters: [
                  (formal_parameters) @params
                  (identifier) @params
                ]?
                body: [
                  (statement_block)
                  (_)
                ] @body)))) @function

    FUNCTION_EXPRESSION:
      description: "Function expressions assigned to variables"
      capture: "function"
      query: |
        (variable_declarator
          name: (identifier) @name
          value: [
            (function_expression
              name: (identifier)? @fn_name
              parameters: (formal_parameters) @params
              body: (statement_block) @body)
            (generator_function
              name: (identifier)? @fn_name
              parameters: (formal_parameters) @params
              body: (statement_block) @body)
          ] @value) @function

    CONST:
      description: "Const declarations (excluding functions)"
      capture: "const"
      query: |
        (
          (lexical_declaration
            kind: "const"
            (variable_declarator
              name: (identifier) @name
              value: (_) @value)) @const
          (#not-match? @value "^(function|async function|\\(|\\w+\\s*=>)")
        )

        (
          (export_statement
            declaration: (lexical_declaration
              kind: "const"
              (variable_declarator
                name: (identifier) @name
                value: (_) @value))) @const
          (#not-match? @value "^(function|async function|\\(|\\w+\\s*=>)")
        )

    LET:
      description: "Let declarations"
      capture: "let"
      query: |
        (lexical_declaration
          kind: "let"
          (variable_declarator
            name: (identifier) @name
            value: (_)? @value)) @let

    VAR:
      description: "Var declarations"
      capture: "var"
      query: |
        (variable_declaration
          (variable_declarator
            name: (identifier) @name
            value: (_)? @value)) @var

    METHOD_DEFINITION:
      description: "Class method definitions"
      capture: "method"
      query: |
        (class_body
          (method_definition
            name: (property_identifier) @name
            parameters: (formal_parameters) @params
            body: (statement_block) @body) @method)

    MODULE:
      description: "Module (program node) for file-level entity"
      capture: "program"
      query: |
        (program) @program

  # ---------------------------------------------------------------------------
  # Extractors
  # ---------------------------------------------------------------------------
  # TypeScript inherits JavaScript extractors and adds:

  extractors:

    # Inherits from JavaScript:
    # - function_metadata
    # - arrow_function_metadata
    # - method_metadata
    # - const_metadata
    # - property_metadata
    # - extract_function_relationships
    # - extract_class_relationships
    # - extract_module_relationships

    enum_metadata:
      description: "Extract enum metadata (is_const)"
      metadata_fields:
        - is_const: "Check for const keyword before enum"

    extract_interface_relationships:
      description: "Extract interface extends and type usages"
      relationship_fields:
        - extended_types: "Types from extends clause"
        - uses_types: "Type references in body"

  # ---------------------------------------------------------------------------
  # Handlers
  # ---------------------------------------------------------------------------
  # TypeScript handlers extend JavaScript handlers with TS-specific entities.

  handlers:

    # ---------------------------------------------------------------------------
    # JavaScript-compatible handlers
    # ---------------------------------------------------------------------------
    # These handlers use the JS-compatible queries defined above.

    FunctionDeclaration:
      entity_rule: E-FN-DECL
      query: FUNCTION_DECLARATION
      capture: "function"
      name_strategy: capture
      metadata: function_metadata
      relationships: extract_function_relationships

    ArrowFunction:
      entity_rule: E-FN-ARROW
      query: ARROW_FUNCTION
      capture: "function"
      name_strategy: capture
      metadata: arrow_function_metadata
      relationships: extract_function_relationships

    FunctionExpression:
      entity_rule: E-FN-EXPR
      query: FUNCTION_EXPRESSION
      capture: "function"
      name_strategy: fallback
      name_captures: ["fn_name", "name"]
      metadata: function_metadata
      relationships: extract_function_relationships

    Const:
      entity_rule: E-CONST
      query: CONST
      capture: "const"
      name_strategy: capture
      metadata: const_metadata

    Let:
      entity_rule: E-VAR-LET
      query: LET
      capture: "let"
      name_strategy: capture

    Var:
      entity_rule: E-VAR-VAR
      query: VAR
      capture: "var"
      name_strategy: capture

    ClassDeclaration:
      entity_rule: E-CLASS
      query: TS_CLASS_DECLARATION
      capture: "class"
      name_strategy: capture
      relationships: extract_class_relationships

    ClassExpression:
      entity_rule: E-CLASS-EXPR
      query: TS_CLASS_EXPRESSION
      capture: "class"
      name_strategy: fallback
      name_captures: ["name", "class_name"]
      relationships: extract_class_relationships

    MethodDefinition:
      entity_rule: E-METHOD-CLASS
      query: METHOD_DEFINITION
      capture: "method"
      name_strategy: capture
      metadata: method_metadata
      relationships: extract_function_relationships

    FieldDefinition:
      entity_rule: E-PROPERTY-FIELD
      query: TS_PROPERTY
      capture: "property"
      name_strategy: capture
      metadata: property_metadata

    Module:
      entity_rule: E-MOD-FILE
      query: MODULE
      capture: "program"
      name_strategy: file_path
      qualified_name_template: "{name}"
      relationships: extract_module_relationships

    # ---------------------------------------------------------------------------
    # Interface handlers
    # ---------------------------------------------------------------------------

    Interface:
      entity_rule: E-INTERFACE
      query: INTERFACE
      capture: "interface"
      name_strategy: capture
      relationships: extract_interface_relationships

    InterfaceProperty:
      entity_rule: E-INTERFACE-PROPERTY
      query: INTERFACE_PROPERTY
      capture: "interface_property"
      name_strategy: capture
      visibility_override: Public

    InterfaceMethod:
      entity_rule: E-INTERFACE-METHOD
      query: INTERFACE_METHOD
      capture: "interface_method"
      name_strategy: capture
      visibility_override: Public

    CallSignature:
      entity_rule: E-INTERFACE-CALL-SIG
      query: CALL_SIGNATURE
      capture: "call_signature"
      name_strategy: static
      static_name: "()"
      visibility_override: Public

    ConstructSignature:
      entity_rule: E-INTERFACE-CONSTRUCT-SIG
      query: CONSTRUCT_SIGNATURE
      capture: "construct_signature"
      name_strategy: static
      static_name: "new()"
      visibility_override: Public

    IndexSignature:
      entity_rule: E-INTERFACE-INDEX-SIG
      query: INDEX_SIGNATURE
      capture: "index_signature"
      name_strategy: static
      static_name: "[index]"
      visibility_override: Public

    # --- Type alias handlers ---

    TypeAlias:
      entity_rule: E-TYPE-ALIAS
      query: TYPE_ALIAS
      capture: "type_alias"
      name_strategy: capture

    # --- Enum handlers ---

    Enum:
      entity_rule: E-ENUM
      query: ENUM
      capture: "enum"
      name_strategy: capture
      metadata: enum_metadata

    EnumMember:
      entity_rule: E-ENUM-MEMBER
      query: ENUM_MEMBER
      capture: "enum_member"
      name_strategy: capture

    # --- Namespace handlers ---

    Namespace:
      entity_rule: E-MOD-NAMESPACE
      query: NAMESPACE
      capture: "namespace"
      name_strategy: capture

    # --- Abstract method handlers ---

    AbstractMethod:
      entity_rule: E-METHOD-ABSTRACT
      query: ABSTRACT_METHOD
      capture: "method"
      name_strategy: capture
      visibility_override: Public

    # --- Ambient declaration handlers ---

    AmbientFunction:
      entity_rule: E-AMBIENT-FN
      query: AMBIENT_FUNCTION
      capture: "function"
      name_strategy: capture
      visibility_override: Public

    AmbientConst:
      entity_rule: E-AMBIENT-CONST
      query: AMBIENT_CONST
      capture: "const"
      name_strategy: capture
      visibility_override: Public
      metadata: const_metadata

    AmbientLet:
      entity_rule: E-AMBIENT-LET
      query: AMBIENT_LET
      capture: "let"
      name_strategy: capture
      visibility_override: Public

    AmbientVar:
      entity_rule: E-AMBIENT-VAR
      query: AMBIENT_VAR
      capture: "var"
      name_strategy: capture
      visibility_override: Public

    AmbientClass:
      entity_rule: E-AMBIENT-CLASS
      query: AMBIENT_CLASS
      capture: "class"
      name_strategy: capture
      visibility_override: Public
      relationships: extract_class_relationships

    # --- Parameter property handlers ---

    ParameterProperty:
      entity_rule: E-PARAM-PROPERTY
      query: PARAMETER_PROPERTY
      capture: "property"
      name_strategy: capture
      skip_scopes: ["method_definition"]  # Place under class, not constructor


# =============================================================================
# TEST FIXTURE MAPPING
# =============================================================================
# Maps test fixtures to the rules they verify.

fixtures:
  basic_module:
    tests: [E-MOD-FILE, V-EXPORT, Q-MODULE-FILE, R-CONTAINS-MODULE-ITEM]

  imports_exports:
    tests: [E-MOD-FILE, R-IMPORTS-NAMED, R-IMPORTS-DEFAULT, R-IMPORTS-NAMESPACE, R-IMPORTS-TYPE]

  namespaces:
    tests: [E-MOD-NAMESPACE, V-NAMESPACE-EXPORT, Q-MODULE-NAMESPACE, Q-ITEM-NAMESPACE, R-CONTAINS-NAMESPACE-ITEM]

  nested_namespaces:
    tests: [E-MOD-NAMESPACE, Q-MODULE-NAMESPACE]

  namespace_merging:
    tests: [E-MOD-NAMESPACE-MERGED]

  classes:
    tests: [E-CLASS, V-CLASS-PUBLIC, Q-ITEM-MODULE, R-CONTAINS-CLASS-MEMBER]

  abstract_classes:
    tests: [E-CLASS-ABSTRACT, E-METHOD-ABSTRACT, M-CLASS-ABSTRACT, M-METHOD-ABSTRACT]

  class_expressions:
    tests: [E-CLASS-EXPR]

  class_inheritance:
    tests: [E-CLASS, R-INHERITS-FROM]

  class_implements:
    tests: [E-CLASS, E-INTERFACE, R-IMPLEMENTS]

  class_fields:
    tests: [E-PROPERTY-FIELD, Q-PROPERTY-INSTANCE, M-FIELD-INITIALIZER]

  parameter_properties:
    tests: [E-PROPERTY-PARAM]

  private_fields:
    tests: [E-PROPERTY-PRIVATE-FIELD, V-CLASS-PRIVATE-FIELD]

  arrow_field_properties:
    tests: [E-PROPERTY-ARROW-FIELD]

  interfaces:
    tests: [E-INTERFACE, E-PROPERTY-INTERFACE, V-INTERFACE-MEMBER, Q-INTERFACE-METHOD, Q-INTERFACE-PROPERTY, R-CONTAINS-INTERFACE-MEMBER]

  interface_properties:
    tests: [E-PROPERTY-INTERFACE, M-PROPERTY-OPTIONAL, M-PROPERTY-READONLY]

  interface_extends:
    tests: [E-INTERFACE, R-EXTENDS-INTERFACE]

  interface_merging:
    tests: [E-INTERFACE-MERGED]

  type_aliases:
    tests: [E-TYPE-ALIAS, V-TYPE-ALIAS]

  generic_type_aliases:
    tests: [E-TYPE-ALIAS, M-GENERIC]

  enums:
    tests: [E-ENUM, E-ENUM-MEMBER, R-CONTAINS-ENUM-MEMBER, M-ENUM-NUMERIC]

  string_enums:
    tests: [E-ENUM, E-ENUM-MEMBER, M-ENUM-STRING]

  heterogeneous_enums:
    tests: [E-ENUM, M-ENUM-HETEROGENEOUS]

  const_enums:
    tests: [E-ENUM-CONST, M-ENUM-CONST]

  functions:
    tests: [E-FN-DECL, Q-ITEM-MODULE]

  function_expressions:
    tests: [E-FN-EXPR]

  arrow_functions:
    tests: [E-FN-ARROW, M-FN-ARROW]

  async_functions:
    tests: [E-FN-DECL, M-FN-ASYNC]

  generator_functions:
    tests: [E-FN-GENERATOR, M-FN-GENERATOR]

  overloaded_functions:
    tests: [E-FN-DECL, M-FN-OVERLOADED]

  methods:
    tests: [E-METHOD-CLASS, V-CLASS-PUBLIC, Q-METHOD-INSTANCE, R-CONTAINS-CLASS-MEMBER]

  static_methods:
    tests: [E-METHOD-STATIC, Q-METHOD-STATIC, M-METHOD-STATIC]

  accessors:
    tests: [E-METHOD-GETTER, E-METHOD-SETTER, M-METHOD-ACCESSOR-GET, M-METHOD-ACCESSOR-SET]

  private_members:
    tests: [V-CLASS-PRIVATE]

  protected_members:
    tests: [V-CLASS-PROTECTED]

  constants:
    tests: [E-CONST]

  exported_constants:
    tests: [E-CONST, V-EXPORT]

  variables:
    tests: [E-VAR-LET]

  static_properties:
    tests: [E-PROPERTY-FIELD, Q-PROPERTY-STATIC, M-PROPERTY-STATIC]

  readonly_properties:
    tests: [M-PROPERTY-READONLY]

  optional_properties:
    tests: [M-PROPERTY-OPTIONAL]

  exports:
    tests: [V-EXPORT]

  reexports:
    tests: [V-EXPORT, R-REEXPORTS-NAMED, R-REEXPORTS-DEFAULT]

  barrel_exports:
    tests: [R-REEXPORTS-ALL]

  namespace_reexports:
    tests: [R-REEXPORTS-NAMESPACE]

  default_exports:
    tests: [V-EXPORT-DEFAULT, R-IMPORTS-DEFAULT]

  type_imports:
    tests: [R-IMPORTS-TYPE]

  namespace_imports:
    tests: [R-IMPORTS-NAMESPACE]

  visibility:
    tests: [V-CLASS-PUBLIC, V-CLASS-PRIVATE, V-CLASS-PROTECTED, V-MODULE-PRIVATE, V-EXPORT]

  function_calls:
    tests: [R-CALLS-FUNCTION]

  method_calls:
    tests: [R-CALLS-FUNCTION]

  type_usage:
    tests: [R-USES-TYPE]

  generic_classes:
    tests: [E-CLASS, M-GENERIC]

  generic_functions:
    tests: [E-FN-DECL, M-GENERIC]

  generic_interfaces:
    tests: [E-INTERFACE, M-GENERIC]

  generic_constraints:
    tests: [M-GENERIC-CONSTRAINT, R-USES-TYPE]

  generic_defaults:
    tests: [M-GENERIC-DEFAULT]

  decorators:
    tests: [M-DECORATOR]

  experimental_decorators:
    tests: [M-DECORATOR, M-DECORATOR-PARAM]

  # ---------------------------------------------------------------------------
  # Ambient declarations (.d.ts files)
  # ---------------------------------------------------------------------------
  ambient_declarations:
    tests: [E-AMBIENT-VAR, E-AMBIENT-FUNCTION, E-AMBIENT-CLASS, E-AMBIENT-NAMESPACE]

  global_augmentation:
    tests: [E-GLOBAL-AUGMENTATION]

  # ---------------------------------------------------------------------------
  # Signatures
  # ---------------------------------------------------------------------------
  index_signatures:
    tests: [E-INDEX-SIGNATURE]

  call_signatures:
    tests: [E-CALL-SIGNATURE]

  construct_signatures:
    tests: [E-CONSTRUCT-SIGNATURE]

  # ---------------------------------------------------------------------------
  # JSX
  # ---------------------------------------------------------------------------
  jsx_components:
    tests: [E-JSX-COMPONENT, E-JSX-ARROW-COMPONENT]
